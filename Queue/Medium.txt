

 Q - Parking Ice Cream Truck

 Problem Description

Imagine you're an ice cream truck driver in a beachside town. The beach is divided into several sections, and each section has varying numbers of beachgoers wanting ice cream given by the array of integers A.

For simplicity, let's say the beach is divided into 8 sections. One day, you note down the number of potential customers in each section: [5, 12, 3, 4, 8, 10, 2, 7]. This means there are 5 people in the first section, 12 in the second, and so on.

You can only stop your truck in B consecutive sections at a time because of parking restrictions. To maximize sales, you want to park where the most customers are clustered together.

For all B consecutive sections, identify the busiest stretch to park your ice cream truck and serve the most customers. Return an array C, where C[i] is the busiest section in each of the B consecutive sections. Refer to the given example for clarity.

NOTE: If B > length of the array, return 1 element with the max of the array.












Problem Constraints

1 <= |A|, B <= 106



Input Format

The first argument given is the integer array A.

The second argument given is the integer B.



Output Format

Return an array C, where C[i] is the maximum value from A[i] to A[i+B-1].



Example Input

Input 1:

 A = [1, 3, -1, -3, 5, 3, 6, 7]
 B = 3
Input 2:

 A = [1, 2, 3, 4, 2, 7, 1, 3, 6]
 B = 6


Example Output

Output 1:

 [3, 3, 5, 5, 6, 7]
Output 2:

 [7, 7, 7, 7]


Example Explanation

Explanation 1:

 Window position     | Max
 --------------------|-------
 [1 3 -1] -3 5 3 6 7 | 3
 1 [3 -1 -3] 5 3 6 7 | 3
 1 3 [-1 -3 5] 3 6 7 | 5
 1 3 -1 [-3 5 3] 6 7 | 5
 1 3 -1 -3 [5 3 6] 7 | 6
 1 3 -1 -3 5 [3 6 7] | 7
Explanation 2:

 Window position     | Max
 --------------------|-------
 [1 2 3 4 2 7] 1 3 6 | 7
 1 [2 3 4 2 7 1] 3 6 | 7
 1 2 [3 4 2 7 1 3] 6 | 7
 1 2 3 [4 2 7 1 3 6] | 7

 Approach - 

Brute Force Approach (O(N * B))

For each window of size B, loop through and find the maximum.



Optimized Approach (O(N)) â†’ 

Using Deque

We need an O(N) solution. Thatâ€™s where deque (double-ended queue) helps.

Idea

Maintain a deque of indices, not values.

The deque will always store indices of elements in decreasing order of their values.

The front of the deque (dq.front()) is always the max for the current window.

Steps

Iterate over each index i in array A.

Remove out-of-window indices (if dq.front() <= i - B, pop from front).
â†’ This ensures only current windowâ€™s elements are considered.

Maintain decreasing order in deque:
While dq is not empty and A[dq.back()] <= A[i], pop from back.
â†’ This ensures bigger elements kick out smaller ones because theyâ€™ll never be max while the bigger one is in range.

Push i into deque.

Starting from index i >= B-1, the front of deque is the max for that window.


Code - 

public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int[] slidingMaximum(final int[] A, int B) {

        int n = A.length;

        if( B > n){
            int maxVal = Integer.MIN_VALUE;

            for( int a : A){
                maxVal = Math.max( maxVal, a);
            }

            return new int[]{maxVal};
        }


        Deque<Integer> dq = new ArrayDeque<>();
        List<Integer> result = new ArrayList<>();


        for( int i =0; i < n; i++){

        // remove indices which are not present in the current window

        if( !dq.isEmpty() && dq.peekFirst() <= i-B){
            dq.pollFirst();
        }

        // maintain decreasing order in deque 

        while( !dq.isEmpty() && A[dq.peekLast()] <= A[i] ){
                dq.pollLast();
        }

        dq.offerLast(i);

        // record max element in each window 

        if( i>= B -1){
            result.add(A[dq.peekFirst()]);
        }

        }

        int[] ans = new int[result.size()];

        for( int i =0; i<result.size(); i++){
            ans[i] = result.get(i);
        }
        
        return ans;
    }
}

Q - Unique Letter

Problem Description

Imagine you're a teacher. You ask students to call out a letter one by one. After each letter, you jot down the very first letter that's only been called out once. If all letters have been repeated, you write "#".

Here's a scenario:

A student says "a". It's the first letter. You write "a".
Next, a student says "b", "a" is still unique, so you add "a". Now it's "aa".
A student says "a" again. Now, "b" is the unique one. You add "b", making it "aab".
A student says "b". All letters so far are repeated. You add "#". It becomes "aab#".
A student says "c". "c" is unique. You add "c". The final is "aab#c".
Your task? Given the sequence the students call out A, determine the string on the board.





Problem Constraints

1 <= |A| <= 100000



Input Format

The only argument given is string A.



Output Format

Return a string after processing the stream of lowercase alphabets A.



Example Input

Input 1:

 A = "abadbc"
Input 2:

 A = "abcabc"


Example Output

Output 1:

"aabbdd"
Output 2:

"aaabc#"


Example Explanation

Explanation 1:

"a"      -   first non repeating character 'a'
"ab"     -   first non repeating character 'a'
"aba"    -   first non repeating character 'b'
"abad"   -   first non repeating character 'b'
"abadb"  -   first non repeating character 'd'
"abadbc" -   first non repeating character 'd'
Explanation 2:

"a"      -   first non repeating character 'a'
"ab"     -   first non repeating character 'a'
"abc"    -   first non repeating character 'a'
"abca"   -   first non repeating character 'b'
"abcab"  -   first non repeating character 'c'
"abcabc" -   no non repeating character so '#'


Approach - 

BF - 

For each character in the stream, count its frequency.

Scan all characters from the beginning each time to find the first one with frequency = 1.

Complexity: O(nÂ²) in the worst case (n=100000 â†’ too slow).


Optimized - 

The key idea is:

Map/Array â†’ store how many times each character has appeared.

Queue â†’ maintain characters in the order they appeared.

Ensure the front of the queue always holds the first unique character.

Steps

Create a frequency array freq[26] (since only lowercase letters).

Create a queue q to store the characters in the order they appear.

For each character c in string A:

Increment its frequency.

Push c into q.

While queue is not empty and the frequency of q.front() is more than 1, remove it (q.poll()).

After cleaning:

If queue is not empty, append q.front() to result.

Else, append #.

Complexity

Each character is pushed into the queue once and popped at most once â†’ O(n).

Frequency check and updates are O(1).

Overall: O(n) time, O(26 + n) space (â‰ˆ O(n)).

Code - 

  public String solve(String A) {

        Map<Character, Integer> mp = new HashMap<>();

        Queue<Character> q = new LinkedList<>();

        StringBuilder ans = new StringBuilder();

        for( char c: A.toCharArray()){

            mp.put(c, mp.getOrDefault(c, 0) +1);

            q.add(c);

            while(!q.isEmpty() && mp.get(q.peek()) >1){
                q.poll();
            }

            if(!q.isEmpty()){
                ans.append(q.peek());
            }else{
                ans.append('#');
            }
        }

        return ans.toString();
    }


Q - Sum of min and max


Problem Description

Given an array A of both positive and negative integers.



Your task is to compute the sum of minimum and maximum elements of all sub-array of size B.

NOTE: Since the answer can be very large, you are required to return the sum modulo 109 + 7.





Problem Constraints

1 <= size of array A <= 105

-109 <= A[i] <= 109

1 <= B <= size of array



Input Format

The first argument denotes the integer array A.
The second argument denotes the value B



Output Format

Return an integer that denotes the required value.



Example Input

Input 1:

 A = [2, 5, -1, 7, -3, -1, -2]
 B = 4
Input 2:

 A = [2, -1, 3]
 B = 2


Example Output

Output 1:

 18
Output 2:

 3


Example Explanation

Explanation 1:

 Subarrays of size 4 are : 
    [2, 5, -1, 7],   min + max = -1 + 7 = 6
    [5, -1, 7, -3],  min + max = -3 + 7 = 4      
    [-1, 7, -3, -1], min + max = -3 + 7 = 4
    [7, -3, -1, -2], min + max = -3 + 7 = 4   
    Sum of all min & max = 6 + 4 + 4 + 4 = 18 
Explanation 2:

 Subarrays of size 2 are : 
    [2, -1],   min + max = -1 + 2 = 1
    [-1, 3],   min + max = -1 + 3 = 2
    Sum of all min & max = 1 + 2 = 3 


Approach - 


Brute Force (BF) Approach
Idea

For every subarray of size B, scan through its elements to find min and max, then add (min + max) to the result.

Steps

Loop i from 0 to n - B.

For subarray A[i..i+B-1], scan all elements:

Find min

Find max

Add (min + max) to answer.

Return answer modulo 1e9+7.

Complexity

For each of the n-B+1 subarrays, finding min & max costs O(B).

Time: O(n * B) â†’ too slow for n=10^5 if B is large.

Space: O(1).


Optimized Approach (Deque â€“ Sliding Window)

The trick is:
We donâ€™t want to recompute min & max from scratch for each subarray. Instead, maintain them dynamically as the window slides.

Data Structures

A deque for max values (monotonic decreasing â†’ front always max).

A deque for min values (monotonic increasing â†’ front always min).

Steps

Initialize two deques: maxDeque, minDeque.

Process the first B elements:

Insert each element while maintaining order (pop from back if smaller for maxDeque, larger for minDeque).

Add (maxDeque.front + minDeque.front) to result.

For each new element A[i] from B â†’ n-1:

Remove elements that are out of this window (i - B index).

Insert current element into both deques, maintaining monotonic property.

Add (maxDeque.front + minDeque.front) to result.

Return result modulo 1e9+7.

Complexity

Each element is pushed & popped from each deque at most once.

Time: O(n)

Space: O(B)

ðŸ”¹ Example Walkthrough

Input:
A = [2, 5, -1, 7, -3, -1, -2], B = 4

Window [2, 5, -1, 7] â†’ min=-1, max=7 â†’ sum=6

Window [5, -1, 7, -3] â†’ min=-3, max=7 â†’ sum=4

Window [-1, 7, -3, -1] â†’ min=-3, max=7 â†’ sum=4

Window [7, -3, -1, -2] â†’ min=-3, max=7 â†’ sum=4

Answer = 18.



Code  - 


public class Solution {
    public int solve(int[] A, int B) {

    long mod = 1000000007;
        long sum = 0;

        Deque<Integer> maxDeque = new LinkedList<>();
        Deque<Integer> minDeque = new LinkedList<>();

        for (int i = 0; i < A.length; i++) {
            // remove elements out of window
            if (!maxDeque.isEmpty() && maxDeque.peekFirst() <= i - B) {
                maxDeque.pollFirst();
            }
            if (!minDeque.isEmpty() && minDeque.peekFirst() <= i - B) {
                minDeque.pollFirst();
            }

            // maintain increasing deque for min
            while (!minDeque.isEmpty() && A[minDeque.peekLast()] >= A[i]) {
                minDeque.pollLast();
            }
            minDeque.offerLast(i);

            // maintain decreasing deque for max
            while (!maxDeque.isEmpty() && A[maxDeque.peekLast()] <= A[i]) {
                maxDeque.pollLast();
            }
            maxDeque.offerLast(i);

            // when window is ready
            if (i >= B - 1) {

                long maxVal = A[maxDeque.peekFirst()];
                long  minVal = A[minDeque.peekFirst()];


                sum = (sum + ( (maxVal + minVal) % mod  ) + mod ) % mod;
            }
        }

        return (int) sum;

    }
}
