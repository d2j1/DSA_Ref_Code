

 Q - Parking Ice Cream Truck

 Problem Description

Imagine you're an ice cream truck driver in a beachside town. The beach is divided into several sections, and each section has varying numbers of beachgoers wanting ice cream given by the array of integers A.

For simplicity, let's say the beach is divided into 8 sections. One day, you note down the number of potential customers in each section: [5, 12, 3, 4, 8, 10, 2, 7]. This means there are 5 people in the first section, 12 in the second, and so on.

You can only stop your truck in B consecutive sections at a time because of parking restrictions. To maximize sales, you want to park where the most customers are clustered together.

For all B consecutive sections, identify the busiest stretch to park your ice cream truck and serve the most customers. Return an array C, where C[i] is the busiest section in each of the B consecutive sections. Refer to the given example for clarity.

NOTE: If B > length of the array, return 1 element with the max of the array.












Problem Constraints

1 <= |A|, B <= 106



Input Format

The first argument given is the integer array A.

The second argument given is the integer B.



Output Format

Return an array C, where C[i] is the maximum value from A[i] to A[i+B-1].



Example Input

Input 1:

 A = [1, 3, -1, -3, 5, 3, 6, 7]
 B = 3
Input 2:

 A = [1, 2, 3, 4, 2, 7, 1, 3, 6]
 B = 6


Example Output

Output 1:

 [3, 3, 5, 5, 6, 7]
Output 2:

 [7, 7, 7, 7]


Example Explanation

Explanation 1:

 Window position     | Max
 --------------------|-------
 [1 3 -1] -3 5 3 6 7 | 3
 1 [3 -1 -3] 5 3 6 7 | 3
 1 3 [-1 -3 5] 3 6 7 | 5
 1 3 -1 [-3 5 3] 6 7 | 5
 1 3 -1 -3 [5 3 6] 7 | 6
 1 3 -1 -3 5 [3 6 7] | 7
Explanation 2:

 Window position     | Max
 --------------------|-------
 [1 2 3 4 2 7] 1 3 6 | 7
 1 [2 3 4 2 7 1] 3 6 | 7
 1 2 [3 4 2 7 1 3] 6 | 7
 1 2 3 [4 2 7 1 3 6] | 7

 Approach - 

Brute Force Approach (O(N * B))

For each window of size B, loop through and find the maximum.



Optimized Approach (O(N)) → 

Using Deque

We need an O(N) solution. That’s where deque (double-ended queue) helps.

Idea

Maintain a deque of indices, not values.

The deque will always store indices of elements in decreasing order of their values.

The front of the deque (dq.front()) is always the max for the current window.

Steps

Iterate over each index i in array A.

Remove out-of-window indices (if dq.front() <= i - B, pop from front).
→ This ensures only current window’s elements are considered.

Maintain decreasing order in deque:
While dq is not empty and A[dq.back()] <= A[i], pop from back.
→ This ensures bigger elements kick out smaller ones because they’ll never be max while the bigger one is in range.

Push i into deque.

Starting from index i >= B-1, the front of deque is the max for that window.


Code - 

public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int[] slidingMaximum(final int[] A, int B) {

        int n = A.length;

        if( B > n){
            int maxVal = Integer.MIN_VALUE;

            for( int a : A){
                maxVal = Math.max( maxVal, a);
            }

            return new int[]{maxVal};
        }


        Deque<Integer> dq = new ArrayDeque<>();
        List<Integer> result = new ArrayList<>();


        for( int i =0; i < n; i++){

        // remove indices which are not present in the current window

        if( !dq.isEmpty() && dq.peekFirst() <= i-B){
            dq.pollFirst();
        }

        // maintain decreasing order in deque 

        while( !dq.isEmpty() && A[dq.peekLast()] <= A[i] ){
                dq.pollLast();
        }

        dq.offerLast(i);

        // record max element in each window 

        if( i>= B -1){
            result.add(A[dq.peekFirst()]);
        }

        }

        int[] ans = new int[result.size()];

        for( int i =0; i<result.size(); i++){
            ans[i] = result.get(i);
        }
        
        return ans;
    }
}


