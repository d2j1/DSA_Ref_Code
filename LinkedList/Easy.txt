Q - Insert in Linked List

You are given A which is the head of a linked list. Also given is the value B and position C. Complete the function that should insert a new node with the said value at the given position.

Notes:

In case the position is more than length of linked list, simply insert the new node at the tail only.
In case the pos is 0, simply insert the new node at head only.
Follow 0-based indexing for the node numbering.


Problem Constraints

0 <= size of linked list <= 105

1 <= value of nodes <= 109

1 <= B <= 109

0 <= C <= 105



Input Format

The first argument A is the head of a linked list.

The second argument B is an integer which denotes the value of the new node

The third argument C is an integer which denotes the position of the new node



Output Format

Return the head of the linked list


Example Input

Input 1:
A = 1 -> 2
B = 3
C = 0
Input 2:
A = 1 -> 2
B = 3
C = 1


Example Output

Output 1:
3 -> 1 -> 2
Output 2:
1 -> 3 -> 2


Example Explanation

For Input 1:
The new node is add to the head of the linked list
For Input 2:
The new node is added after the first node of the linked list


Code - 

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode solve(ListNode A, int B, int C) {

        ListNode newNode = new ListNode(B);

      if(A==null){
          A = newNode;
          return A;
      }

    

      if( C == 0){
          newNode.next = A;
          return newNode;
      }

    ListNode temp = A;  
        boolean isReachedEnd=false;

        for( int i=0; i<C-1; i++){
            if(temp.next == null){
                isReachedEnd=true;
                break;
            }
            temp = temp.next;
        }

        if( isReachedEnd ){
            temp.next = newNode;
            return A;
        }else{
            newNode.next = temp.next;
            temp.next = newNode;
            return A;
        }



    }
}


Q - Delete in Linked List

You are given the head of a linked list A and an integer B. Delete the B-th node from the linked list.

Note : Follow 0-based indexing for the node numbering.



Problem Constraints

1 <= size of linked list <= 105
1 <= value of nodes <= 109
0 <= B < size of linked list




Input Format

The first argument A is the head of a linked list.

The second arguement B is an integer.



Output Format

Return the head of the linked list after deletion



Example Input

Input 1:
A = 1 -> 2 -> 3
B = 1
Input 2:
A = 4 -> 3 -> 2 -> 1
B = 0


Example Output

Output 1:
1 -> 3
Output 2:
3 -> 2 -> 1


Example Explanation

For Input 1:
The linked list after deletion is 1 -> 3.
For Input 2:
The linked list after deletion is 3 -> 2 -> 1.


Code - 

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode solve(ListNode A, int B) {


        ListNode temp = A;

        if( A == null ){
            return A;
        }

        if(B==0){
            return temp.next;
        }

        for(int i=0; i< B-1; i++){
            temp = temp.next;
        }

        // 1, 17
        temp.next = temp.next.next;

        return A;
    }
}


Q - Reverse Linked List

You are given a singly linked list having head node A. You have to reverse the linked list and return the head node of that reversed list.

NOTE: You have to do it in-place and in one-pass.



Problem Constraints

1 <= Length of linked list <= 105

Value of each node is within the range of a 32-bit integer.



Input Format

First and only argument is a linked-list node A.



Output Format

Return a linked-list node denoting the head of the reversed linked list.



Example Input

Input 1:

 A = 1 -> 2 -> 3 -> 4 -> 5 -> NULL 
Input 2:

 A = 3 -> NULL 


Example Output

Output 1:

 5 -> 4 -> 3 -> 2 -> 1 -> NULL 
Output 2:

 3 -> NULL 


Example Explanation

Explanation 1:

 The linked list has 5 nodes. After reversing them, the list becomes : 5 -> 4 -> 3 -> 2 -> 1 -> NULL 
Expalantion 2:

 The linked list consists of only a single node. After reversing it, the list becomes : 3 -> NULL 

 Approach - 

We want to reverse the direction of links between nodes. Normally, each node points to its next. After reversing, each node should point to its previous node.

To achieve this, we keep track of three pointers while traversing:

prev â†’ keeps track of the previous node (initially null because the new last node will point to nothing).

curr â†’ the current node we are processing.

next â†’ temporarily stores the next node, so we donâ€™t lose the rest of the list when we break links.

ðŸ”„ Steps of the Algorithm

Initialize:

prev = null

curr = head

While curr != null:

Save the next node:
next = curr.next

Reverse the link:
curr.next = prev

Move prev forward:
prev = curr

Move curr forward:
curr = next

When the loop ends, prev will be the new head of the reversed list.


 Code -  

 /**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode A) {

        ListNode prev=null, curr=A, nxt=null;

        while( curr != null){
            nxt = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nxt;
        }

        return prev;
    }
}



Q - Remove Duplicates from Sorted List

Problem Description

Given a sorted linked list, delete all duplicates such that each element appears only once.



Problem Constraints

0 <= length of linked list <= 106



Input Format

First argument is the head pointer of the linked list.



Output Format

Return the head pointer of the linked list after removing all duplicates.



Example Input

Input 1:

 1->1->2
Input 2:

 1->1->2->3->3


Example Output

Output 1:

 1->2
Output 2:

 1->2->3


Example Explanation

Explanation 1:

 Each element appear only once in 1->2.

 Code - 

 /**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode A) {

        ListNode temp = A;

        while( temp != null){
            
            if( temp.next != null && temp.val == temp.next.val){
                ListNode temp2 = temp.next;

                while( temp2 != null && temp2.val == temp.val){
                    temp2= temp2.next;
                }

                temp.next = temp2;    
            }else{
                temp = temp.next;
            }
        }

        return A;
    }
}


Q - Remove Nth Node from List End

Given a linked list A, remove the B-th node from the end of the list and return its head.
For example, given linked list: 1->2->3->4->5, and B = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.

NOTE: If B is greater than the size of the list, remove the first node of the list.

Try doing it using constant additional space.



Problem Constraints

1 <= |A| <= 106


Input Format

The first argument of input contains a pointer to the head of the linked list. The second argument of input contains the integer B.


Output Format

Return the head of the linked list after deleting the B-th element from the end.


Example Input

Input 1:
A = 1->2->3->4->5
B = 2
Input 2:
A = 1
B = 1


Example Output

Output 1:
1->2->3->5
Output 2:
  


Example Explanation

Explanation 1:
In the first example, 4 is the second last element.
Explanation 2:
In the second example, 1 is the first and the last element.


Approach - 

BF - 

Find length of the list

Traverse once, count total nodes = len.

Find target position from start

The node to remove is at index (len - n) (0-based), or (len - n + 1) (1-based).

Second traversal

Traverse again until just before the node, and change links to skip it.

Optimization - 

Use two pointers: fast and slow.

Move fast pointer n steps ahead first.

Then move both fast and slow together until fast reaches the end.

Now slow is just before the node to remove.

Skip that node: slow.next = slow.next.next.

This avoids calculating length.

Code - 

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode A, int B) {

        ListNode slow=A, fast = A;

        for(int i=0; i<B; i++){
            if(fast == null){
                return A.next;
            }
            fast = fast.next;
        }

        while( fast != null && fast.next != null){
            fast = fast.next;
            slow = slow.next;
        }

        if( slow == A){
            A = slow.next;
        }else if(slow.next != null){
        slow.next = slow.next.next;
        }else{
           return A;
        }

        return A;
    }
}


