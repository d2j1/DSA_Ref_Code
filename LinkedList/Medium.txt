Q - Copy List

Problem Description

You are given a linked list A
Each node in the linked list contains two pointers: a next pointer and a random pointer
The next pointer points to the next node in the list
The random pointer can point to any node in the list, or it can be NULL
Your task is to create a deep copy of the linked list A
The copied list should be a completely separate linked list from the original list, but with the same node values and random pointer connections as the original list
You should create a new linked list B, where each node in B has the same value as the corresponding node in A
The next and random pointers of each node in B should point to the corresponding nodes in B (rather than A)


Problem Constraints

0 <= |A| <= 106



Input Format

The first argument of input contains a pointer to the head of linked list A.



Output Format

Return a pointer to the head of the required linked list.



Example Input

Given list
   1 -> 2 -> 3
with random pointers going from
  1 -> 3
  2 -> 1
  3 -> 1
  


Example Output

   1 -> 2 -> 3
with random pointers going from
  1 -> 3
  2 -> 1
  3 -> 1
  

  Approach - 

Approach 1: Using hashmap.

Create a new linked list B by traversing the original linked list A and creating a new node for each node in A.
While traversing A, create a hash map where the keys are the nodes in A and the values are the corresponding nodes in B.
Traverse A again, and for each node in A, use the hash map to find the corresponding node in B. Then, update the next pointer of the current node in B to the corresponding node’s next pointer in A, and update the random pointer of the current node in B to the corresponding node’s random pointer in A.
Return the head of the copied linked list B.


Approach 2 : Using 2 traversals of the list.

Traverse the original linked list A and create a new node A’ for each existing node A and join them together. For example, if the original list is A->B->C, then the new list will be A->A’->B->B’->C->C’.
Traverse the new list and copy the random links. For each new node A’, set its random pointer to the corresponding node’s next pointer in the original list. That is, A’.random = A.random.next.
Detach the new list from the original list by updating the next pointers. Traverse the new list again and set each node’s next pointer to its next next pointer. For example, if the current node is A’, then A’.next = A’.next.next. Also, set each node’s original next pointer to its original next pointer by setting A.next = A.next.next.
Return the head of the new list, which is the second node in the list since the first node is a dummy node.

Code - 

/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {

        HashMap<RandomListNode, RandomListNode> hm = new HashMap<>();

        RandomListNode temp = head;

        while(temp != null){
            RandomListNode newNode = new RandomListNode(temp.label);
            hm.put(temp, newNode);
            temp = temp.next;
        }

        temp = head;

        RandomListNode headCopy = hm.get(temp);

        while(temp != null){
            RandomListNode newTemp = hm.get(temp);
            newTemp.next = hm.get(temp.next);
            newTemp.random = hm.get(temp.random);
            temp = temp.next;
        }

        return headCopy;
    }
}

Q -  Reverse Link List II


Reverse a linked list A from position B to C.

NOTE: Do it in-place and in one-pass.



Problem Constraints

1 <= |A| <= 106

1 <= B <= C <= |A|



Input Format

The first argument contains a pointer to the head of the given linked list, A.

The second arugment contains an integer, B.

The third argument contains an integer C.



Output Format

Return a pointer to the head of the modified linked list.



Example Input

Input 1:

 A = 1 -> 2 -> 3 -> 4 -> 5
 B = 2
 C = 4

Input 2:

 A = 1 -> 2 -> 3 -> 4 -> 5
 B = 1
 C = 5


Example Output

Output 1:

 1 -> 4 -> 3 -> 2 -> 5
Output 2:

 5 -> 4 -> 3 -> 2 -> 1


Example Explanation

Explanation 1:

 In the first example, we want to reverse the highlighted part of the given linked list : 1 -> 2 -> 3 -> 4 -> 5 
 Thus, the output is 1 -> 4 -> 3 -> 2 -> 5 
Explanation 2:

 In the second example, we want to reverse the highlighted part of the given linked list : 1 -> 4 -> 3 -> 2 -> 5  
 Thus, the output is 5 -> 4 -> 3 -> 2 -> 1 


 Appraoch - Reverse nodes from B to C and then join this reversed part to the 
 original linkedlist.

 Code - 

 /**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode reverseBetween(ListNode A, int B, int C) {

        if (A == null || B == C) {
            return A;
        }

        ListNode dummy = new ListNode(-1);
        dummy.next = A;
        ListNode prev = dummy;

        for (int i = 0; i < B - 1; i++) {
            prev = prev.next;
        }

        ListNode start = prev.next;
        ListNode then = start.next;

        for (int i = 0; i < C - B; i++) {
            start.next = then.next;
            then.next = prev.next;
            prev.next = then;
            then = start.next;
        }

        return dummy.next;
    }
}



Q - K reverse linked list

Problem Description

Given a singly linked list A and an integer B, reverse the nodes of the list B at a time and return the modified linked list.



Problem Constraints

1 <= |A| <= 103

B always divides A



Input Format

The first argument of input contains a pointer to the head of the linked list.

The second arugment of input contains the integer, B.



Output Format

Return a pointer to the head of the modified linked list.



Example Input

Input 1:

 A = [1, 2, 3, 4, 5, 6]
 B = 2
Input 2:

 A = [1, 2, 3, 4, 5, 6]
 B = 3


Example Output

Output 1:

 [2, 1, 4, 3, 6, 5]
Output 2:

 [3, 2, 1, 6, 5, 4]


Example Explanation

Explanation 1:

 For the first example, the list can be reversed in groups of 2.
    [[1, 2], [3, 4], [5, 6]]
 After reversing the K-linked list
    [[2, 1], [4, 3], [6, 5]]
Explanation 2:

 For the second example, the list can be reversed in groups of 3.
    [[1, 2, 3], [4, 5, 6]]
 After reversing the K-linked list
    [[3, 2, 1], [6, 5, 4]]


Approach - 


The given linked list can be split into bucket of lenght B.

Reverse linked list in each bucket. 

once all linked lists are reversed then concatenate the lists to get
 a final k-reversed linked list.


Code - 

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     public int val;
 *     public ListNode next;
 *     ListNode(int x) { val = x; next = null; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode A, int B) {
        ListNode head = A;
        
          if (head == null || B == 1) return head;

        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode prevTail = dummy;  // end of previous reversed bucket
        ListNode curr = head;

        while (curr != null) {
            // Step 1: Find the next group of size B
            ListNode groupHead = curr;
            ListNode groupTail = curr;
            for (int i = 1; i < B && groupTail != null; i++) {
                groupTail = groupTail.next;
            }

            // After this, groupTail is at the end of the current bucket
            ListNode nextGroup = groupTail.next; // save the start of the next bucket

            // Step 2: Reverse the current bucket
            ListNode prev = nextGroup;
            ListNode node = groupHead;
            while (node != nextGroup) {
                ListNode temp = node.next;
                node.next = prev;
                prev = node;
                node = temp;
            }

            // Step 3: Connect the previous bucket to the reversed current bucket
            prevTail.next = groupTail;

            // Step 4: Move prevTail to the end of the current bucket
            prevTail = groupHead;
            curr = nextGroup;
        }

        return dummy.next;
    }
}
