Q - Copy List

Problem Description

You are given a linked list A
Each node in the linked list contains two pointers: a next pointer and a random pointer
The next pointer points to the next node in the list
The random pointer can point to any node in the list, or it can be NULL
Your task is to create a deep copy of the linked list A
The copied list should be a completely separate linked list from the original list, but with the same node values and random pointer connections as the original list
You should create a new linked list B, where each node in B has the same value as the corresponding node in A
The next and random pointers of each node in B should point to the corresponding nodes in B (rather than A)


Problem Constraints

0 <= |A| <= 106



Input Format

The first argument of input contains a pointer to the head of linked list A.



Output Format

Return a pointer to the head of the required linked list.



Example Input

Given list
   1 -> 2 -> 3
with random pointers going from
  1 -> 3
  2 -> 1
  3 -> 1
  


Example Output

   1 -> 2 -> 3
with random pointers going from
  1 -> 3
  2 -> 1
  3 -> 1
  

  Approach - 

Approach 1: Using hashmap.

Create a new linked list B by traversing the original linked list A and creating a new node for each node in A.
While traversing A, create a hash map where the keys are the nodes in A and the values are the corresponding nodes in B.
Traverse A again, and for each node in A, use the hash map to find the corresponding node in B. Then, update the next pointer of the current node in B to the corresponding node’s next pointer in A, and update the random pointer of the current node in B to the corresponding node’s random pointer in A.
Return the head of the copied linked list B.


Approach 2 : Using 2 traversals of the list.

Traverse the original linked list A and create a new node A’ for each existing node A and join them together. For example, if the original list is A->B->C, then the new list will be A->A’->B->B’->C->C’.
Traverse the new list and copy the random links. For each new node A’, set its random pointer to the corresponding node’s next pointer in the original list. That is, A’.random = A.random.next.
Detach the new list from the original list by updating the next pointers. Traverse the new list again and set each node’s next pointer to its next next pointer. For example, if the current node is A’, then A’.next = A’.next.next. Also, set each node’s original next pointer to its original next pointer by setting A.next = A.next.next.
Return the head of the new list, which is the second node in the list since the first node is a dummy node.

Code - 

/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {

        HashMap<RandomListNode, RandomListNode> hm = new HashMap<>();

        RandomListNode temp = head;

        while(temp != null){
            RandomListNode newNode = new RandomListNode(temp.label);
            hm.put(temp, newNode);
            temp = temp.next;
        }

        temp = head;

        RandomListNode headCopy = hm.get(temp);

        while(temp != null){
            RandomListNode newTemp = hm.get(temp);
            newTemp.next = hm.get(temp.next);
            newTemp.random = hm.get(temp.random);
            temp = temp.next;
        }

        return headCopy;
    }
}


