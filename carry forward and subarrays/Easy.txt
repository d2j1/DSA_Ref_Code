Q - Closest MinMax

Problem Description

Given an array A, find the size of the smallest subarray such that it contains at least one occurrence of the maximum value of the array

and at least one occurrence of the minimum value of the array.



Problem Constraints

1 <= |A| <= 2000



Input Format

First and only argument is vector A



Output Format

Return the length of the smallest subarray which has at least one occurrence of minimum and maximum element of the array



Example Input

Input 1:

A = [1, 3, 2]
Input 2:

A = [2, 6, 1, 6, 9]


Example Output

Output 1:

 2
Output 2:

 3


Example Explanation

Explanation 1:

 Take the 1st and 2nd elements as they are the minimum and maximum elements respectievly.
Explanation 2:

 Take the last 3 elements of the array.

 Appraoch - 

 This problem can be solved in a simple O(N) complexity.
We can implement a sliding window kind of algorithm using two pointers. We can slide over the array and keep track of every last occurrence of the minimum and maximum element of the array.
In order to find the start point, we can simply remember the last occurrences of a minimum and a maximum value, respectively. And for each min-max pair, we check the length of the subarray that encloses them and then update out overall based on that.

Time Complexity : O(n)
Space Complexity(extra) : O(1)

Code - 

  public int solve(int[] A) {
      int min_ele = Integer.MAX_VALUE, max_ele = Integer.MIN_VALUE;   // min and max value of the array
        int min_Index = -1, max_Index = -1; // index of the last element having value equal to min_ele and max_ele
        
        int ans = Integer.MAX_VALUE;
        for(int x:A){
            min_ele = Math.min(min_ele, x);
            max_ele = Math.max(max_ele, x);
        }
        
        for(int i=0 ; i<A.length ; i++){
            if(A[i] == min_ele) min_Index = Math.max(min_Index, i);
            if(A[i] == max_ele) max_Index = Math.max(max_Index, i);
            
            if(min_Index != -1 && max_Index != -1){
                int len = Math.abs(max_Index - min_Index) + 1;
                ans = Math.min(ans, len);
            }
        }
        
        return ans;

   }

   Q - Generate all subarrays

   Problem Description

You are given an array A of N integers.
Return a 2D array consisting of all the subarrays of the array

Note : The order of the subarrays in the resulting 2D array does not matter.


Problem Constraints

1 <= N <= 100
1 <= A[i] <= 105


Input Format

First argument A is an array of integers.


Output Format

Return a 2D array of integers in any order.


Example Input

Input 1:
A = [1, 2, 3]
Input 2:
A = [5, 2, 1, 4]


Example Output

Output 1:
[[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]
Output 2:
[[1 ], [1 4 ], [2 ], [2 1 ], [2 1 4 ], [4 ], [5 ], [5 2 ], [5 2 1 ], [5 2 1 4 ] ]


Example Explanation

For Input 1:
All the subarrays of the array are returned. There are a total of 6 subarrays.
For Input 2:
All the subarrays of the array are returned. There are a total of 10 subarrays.


Appraoch - 

use two loops to generate start and end point of the subarray.

Code - 

  public int[][] solve(int[] A) {
        
        int n =A.length;
        int totalSubarrays = n * (n+1) / 2;
        int[][] ans = new int[totalSubarrays][];

        int m=0;
        int p=0;
        for( int i=0; i < n; i++){
            
            
            for( int j=0; j <= i; j++){

                ans[m] = new int[i-j+1]; 
                p=0;
                for( int k=j; k<=i; k++){
                    ans[m][p++] = A[k];
                }

                m++;
            }
        }

        return ans;
        
    }


Q - Special Subsequences "AG"


Problem Description

You have given a string A having Uppercase English letters.

You have to find how many times subsequence "AG" is there in the given string.

NOTE: Return the answer modulo 109 + 7 as the answer can be very large.



Problem Constraints

1 <= length(A) <= 105



Input Format

First and only argument is a string A.



Output Format

Return an integer denoting the answer.



Example Input

Input 1:

 A = "ABCGAG"
Input 2:

 A = "GAB"


Example Output

Output 1:

 3
Output 2:

 0


Example Explanation

Explanation 1:

 Subsequence "AG" is 3 times in given string 
Explanation 2:

 There is no subsequence "AG" in the given string.


 Approach - 

 Approach 1

The main task is to find the number of times subsequence “AG” appears in a string.
Simply find the number of G’s after any index i by taking suffix sum.
Then traverse the string again, and when you encounter an ‘A’, add the number of G’s after that to the answer.

Time Complexity : O(n)
Space Complexity (extra) : O(n)

where ‘n’ is the length of the string A.

This solution is enough to pass the test casses.
However , Do we really need O(n) space? Can you think of a solution with constant space?

Approach 2(memory efficient)

This is just a modification of the previous approach.
Instead of keeping a suffix array for count of G’s , we can instead keep a variable ‘g’ storing count of G’s and iterate in the reverse order.
If the current character is ‘G’ , increment g.
If the current character is ‘A’ , add g to our answer.

for i from n-1 to 0
    if A[i]=='G'
        g++
    else 
        ans+=g
        ans%=mod

Time complexity : O(n)
Space complexity : O(1)

Code - 

    public int solve(String A) {
        int cntG=0;

        int ans =0;
        int mod = 1000000007;

        for( int i = A.length()-1; i>=0; i--){

            if( A.charAt(i) == 'G'){
                cntG++;
            }

            if(A.charAt(i) == 'A'){
                ans = ((ans%mod) + (cntG % mod))%mod;
            }
        }

        return ans;
    }


Q - Pick from both sides!

Problem Description

You are given an integer array A of size N.

You have to perform B operations. In one operation, you can remove either the leftmost or the rightmost element of the array A.

Find and return the maximum possible sum of the B elements that were removed after the B operations.

NOTE: Suppose B = 3, and array A contains 10 elements, then you can:

Remove 3 elements from front and 0 elements from the back, OR
Remove 2 elements from front and 1 element from the back, OR
Remove 1 element from front and 2 elements from the back, OR
Remove 0 elements from front and 3 elements from the back.


Problem Constraints

1 <= N <= 105

1 <= B <= N

-103 <= A[i] <= 103








Input Format

First argument is an integer array A.

Second argument is an integer B.








Output Format

Return an integer denoting the maximum possible sum of elements you removed.



Example Input

Input 1:






 A = [5, -2, 3 , 1, 2]
 B = 3
Input 2:

 A = [ 2, 3, -1, 4, 2, 1 ]
 B = 4







Example Output

Output 1:






 8
Output 2:

 9







Example Explanation

Explanation 1:






 Remove element 5 from front and element (1, 2) from back so we get 5 + 1 + 2 = 8
Explanation 2:

 Remove the first element and the last 3 elements. So we get 2 + 4 + 2 + 1 = 9


 Appraoch - 

 Approach using Prefix and Suffix Sums:

Maintain two arrays prefix[i] and suffix[i] where prefix[i] denotes sum of elements from index [0,i] and suffix[i] denotes sum of elements from index [i,N-1].

Now iterate from left and one by one pick elements from left for example: if you pick ‘a’ elements from left and remaining ‘k-a’ elements from right.
So the sum in this case will be prefix[a-1] + suffix[n-(k-a)]

Maintain the maximum among all and return it.

Time Complexity: O(N)
Space Complexity: O(N)

where N is number of elements in array A

Bonus: Try solving it in O(1) space.


Code - 

   public int solve(int[] A, int B) {

        int n = A.length;

        int[] pf = new int[n];

        pf[0] = A[0];

        for( int i=1; i < n ;i++){
            pf[i] = pf[i-1]+A[i];
        }

        int[] sf = new int[n];

        sf[n-1] = A[n-1];
        
        for( int i=n-2; i >= 0; i--){
            sf[i] = sf[i+1] + A[i];
        }

        int sum = Integer.MIN_VALUE;

        for( int i=1; i<=B; i++){

            if(i==1){
                sum = Math.max(sum, sf[n-B]);
            }else if( i==B){
                sum = Math.max(sum, pf[B-1]);
            }else{
                sum = Math.max( sum, pf[i-1] + sf[n-(B-i)] );
            }
        }

        return sum;
    }

Q -  Leaders in an array

Problem Description

Given an integer array A containing N distinct integers, you have to find all the leaders in array A. An element is a leader if it is strictly greater than all the elements to its right side.

NOTE: The rightmost element is always a leader.


Problem Constraints

1 <= N <= 105
1 <= A[i] <= 108


Input Format

There is a single input argument which a integer array A


Output Format

Return an integer array denoting all the leader elements of the array.


Example Input

Input 1:
 A = [16, 17, 4, 3, 5, 2]
Input 2:
 A = [5, 4]


Example Output

Output 1:
[17, 2, 5]
Output 2:
[5, 4]


Example Explanation

Explanation 1:
 Element 17 is strictly greater than all the elements on the right side to it.
 Element 2 is strictly greater than all the elements on the right side to it.
 Element 5 is strictly greater than all the elements on the right side to it.
 So we will return these three elements i.e [17, 2, 5], we can also return [2, 5, 17] or [5, 2, 17] or any other ordering.
Explanation 2:
 Element 5 is strictly greater than all the elements on the right side to it.
 Element 4 is strictly greater than all the elements on the right side to it.
 So we will return these two elements i.e [5, 4], we can also any other ordering.


 Approach - 

 Method 1: (Simple)

Use two loops. The outer loop runs from 0 to size – 1 and, one by one, picks all elements from left to the right. The inner loop compares the picked element to all the elements to its right side. If the picked element is greater than all the elements to its right side, then the picked element is the leader.
Time Complexity: O(N2)

Method 2: (Scan from right) Optimized Approach

Note that for an element to be greater than all the elements towards its right , it just needs to be greater than the maximum element towards its right.
Keep a variable ‘mx’ which stores the maximum till now and initialize it with the last element of the array and also add the last element to our answer array. Iterate from n-2 to 0 , at every index we check if that number is greater than the variable mx. If it is we add the element to our answer array and change mx to that variable.

Time Complexity: O(N)
Space Complexity: O(1)


Code - 

   public int[] solve(int[] A) {

        int gretest = -1;

        ArrayList<Integer> ansList = new ArrayList<Integer>();

        for(int i = A.length-1; i>=0; i--){

                if(gretest < A[i]){
                    ansList.add(A[i]);

                    gretest = A[i];

                }
        }
        int[] ans = new int[ansList.size()];

        for(int i =0; i < ansList.size(); i++){
            ans[i] = ansList.get(i);
        }
        return ans;
    }

    Q - Count Subarrays

Problem Description

Misha likes finding all Subarrays of an Array. Now she gives you an array A of N elements and told you to find the number of subarrays of A, that have unique elements.

Since the number of subarrays could be large, return value % 109 +7.



Problem Constraints

1 <= N <= 105

1 <= A[i] <= 106



Input Format

The only argument given is an Array A, having N integers.



Output Format

Return the number of subarrays of A, that have unique elements.



Example Input

Input 1:

 A = [1, 1, 3]
Input 2:

 A = [2, 1, 2]


Example Output

Output 1:

 4
Output 1:

 5


Example Explanation

Explanation 1:

 Subarrays of A that have unique elements only:
 [1], [1], [1, 3], [3]
Explanation 2:

 Subarrays of A that have unique elements only:
 [2], [1], [2, 1], [1, 2], [2]

Appraoch - 

You can find all subarrays having unique elements using Two Pointers and Hashing.

Maintain two pointer l and r. Store all the elements in the current window in a set.
If the element A[j] is already present in the window, then we keep removing elements
from the left till the window has only unique elements. 
Now the we can have subarrays with unique elements ending at r with any starting index i
in the range l <= i <= r. So the number of subarrays ending at r is given by (r - l + 1).
Add this contribution for all the indices of the array.


Time Complexity : O(NlogN)
Space Complexity : O(N)


 Code - 

     int n = A.size();
        Set<Integer> set = new HashSet<>();
        int left = 0;
        long result = 0;
        int MOD = 1000000007;

        for (int right = 0; right < n; right++) {
            while (set.contains(A.get(right))) {
                set.remove(A.get(left));
                left++;
            }
            set.add(A.get(right));
            result += (right - left + 1);
            result %= MOD;
        }

        return (int) result;

Q - Best Time to Buy and Sell Stocks I

Problem Description

Say you have an array, A, for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Return the maximum possible profit.



Problem Constraints

0 <= A.size() <= 700000



1 <= A[i] <= 107





Input Format

The first and the only argument is an array of integers, A.


Output Format

Return an integer, representing the maximum possible profit.


Example Input

Input 1:
A = [1, 2]
Input 2:

A = [1, 4, 5, 2, 4]


Example Output

Output 1:
1
Output 2:

4


Example Explanation

Explanation 1:
Buy the stock on day 0, and sell it on day 1.
Explanation 2:

Buy the stock on day 0, and sell it on day 2.


Approach - 

If you buy your stock on day i, you’d obviously want to sell it on the day its price is maximum after that day.
So essentially at every index i, you need to find the maximum in the array in the suffix.
Now this part can be done in 2 ways :
1) Have another array which stores that information.
max[i] = max(max[i+1], A[i])

2) Start processing entries from the end maintaining a maximum till now. Constant additional space requirement.


Code - 

  public int maxProfit(final List<Integer> A) {

        if( A.size() ==  0){
            return 0;
        }
        
        int buyPrice = A.get(0);
        int profit = 0;

        for( Integer i : A){

                if( i < buyPrice){
                    buyPrice = i;
                }else{
                    profit = Math.max(i - buyPrice , profit);
                }
        }

        return profit;

    }

    