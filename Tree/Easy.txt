Q -  Inorder Traversal


Problem Description

Given a binary tree, return the inorder traversal of its nodes' values.



Problem Constraints

1 <= number of nodes <= 105



Input Format

First and only argument is root node of the binary tree, A.



Output Format

Return an integer array denoting the inorder traversal of the given binary tree.

Approach - 

a binary tree, inorder traversal means visiting:

Left subtree

Root node

Right subtree

So, the order is:
Left → Root → Right

Code - 

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {
    ArrayList<Integer> ans  = new ArrayList<>();

    public int[] inorderTraversal(TreeNode A) {

        inorder(A);

        int[] ansArr = new int[ans.size()];

        for( int i =0; i<ans.size(); i++){
            ansArr[i] = ans.get(i);
        }
        return ansArr;

    }

    public void inorder(TreeNode A){

        if( A == null){
            return;
        }

        inorder(A.left);
        ans.add(A.val);
        inorder(A.right);
    }
}


Q - Preorder Traversal


Problem Description

Given a binary tree, return the preorder traversal of its nodes values.



Problem Constraints

1 <= number of nodes <= 105



Input Format

First and only argument is root node of the binary tree, A.



Output Format

Return an integer array denoting the preorder traversal of the given binary tree.


Approach - 

binary tree, preorder traversal means visiting nodes in this order:

Root node

Left subtree

Right subtree

So, the order is:
Root → Left → Right


Code - 


/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

    ArrayList<Integer> ansArr = new ArrayList<>();

    public int[] preorderTraversal(TreeNode A) {

        preOrder(A);

        int[] ans = new int[ansArr.size()];

        for( int i = 0; i<ansArr.size(); i++){
            ans[i] = ansArr.get(i);
        }
        
        return ans;

    }

    public void preOrder(TreeNode A){

        if( A== null){
            return;
        }

        ansArr.add(A.val);
        preOrder(A.left);
        preOrder(A.right);
    }
}



Q - Path Sum


Problem Description

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.



Problem Constraints

1 <= number of nodes <= 105

-100000 <= B, value of nodes <= 100000



Input Format

First argument is a root node of the binary tree, A.

Second argument is an integer B denoting the sum.



Output Format

Return 1, if there exist root-to-leaf path such that adding up all the values along the path equals the given sum. Else, return 0.


Appraoch 1 - 

Storing path sum in global array and check if there is sum equal to B.

Code  -


/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

    ArrayList<Integer> ans = new ArrayList<>();

    public int hasPathSum(TreeNode A, int B) {

        calSum(A, 0);

        // for( int i=0; i < ans.size(); i++){
        //     System.out.print(ans.get(i) + " ");
        // }

        for( int i=0; i < ans.size(); i++){
            if(ans.get(i) == B){
                return 1;
            }
        }

       return 0;
    }

    public void calSum(TreeNode A, int B) {

          if(A == null){
            return;
        }

        if(  A.left == null && A.right == null){
            ans.add(B+A.val);
            return;
        }

        
        calSum(A.left, B+A.val);
        calSum(A.right, B + A.val);
    }
}


Approach 2 - 

DFS with Path Sum Accumulation

1. Use DFS (Depth-First Search)

We traverse the tree while maintaining the remaining sum needed to reach target B.

2. Recursive Logic

At each node:

Subtract the node’s value from the target sum.

If we reach a leaf node and the remaining sum == node’s value → ✅ path found.

Otherwise, recursively check left and right subtrees with the updated remaining sum.

3. Base Cases

If the node is null → no path, return false.

If node is a leaf (both children null) and remainingSum == node.val → path exists.


Code - 


/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

    public int hasPathSum(TreeNode A, int B) {

        if(A == null){
            return 0;
        }

        if(  A.left == null && A.right == null){
            return (A.val == B) ? 1: 0;
        }

        
        int left = hasPathSum(A.left, B - A.val);
        int right = hasPathSum(A.right, B - A.val);

       return (left == 1 ||  right == 1) ? 1: 0;
    }

}


Q - Postorder Traversal

Problem Description

Given a binary tree, return the Postorder traversal of its nodes values.



Problem Constraints

1 <= number of nodes <= 105



Input Format

First and only argument is root node of the binary tree, A.



Output Format

Return an integer array denoting the Postorder traversal of the given binary tree.


Approach - 

Postorder traversal, we visit nodes in this order:

Left subtree

Right subtree

Root node

Code - 

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

    ArrayList<Integer> ansArr = new ArrayList<>();

    public int[] postorderTraversal(TreeNode A) {

        postOrder(A);

        int[] ans = new int[ansArr.size()];

        for( int i=0; i<ansArr.size(); i++){
            ans[i] = ansArr.get(i);
        }

        return ans;
    }

    public void postOrder(TreeNode A){

        if( A == null){
            return;
        }

        postOrder(A.left);
        postOrder(A.right);
        ansArr.add(A.val);
    }
}

