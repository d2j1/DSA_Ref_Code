Q - Equal Tree Partition

Given a binary tree A. Check whether it is possible to partition the tree to two trees which have equal sum of values after removing exactly one edge on the original tree.

Problem Constraints

1 <= size of tree <= 100000

0 <= value of node <= 109

Input Format

First and only argument is head of tree A.

Output Format

Return 1 if the tree can be partitioned into two trees of equal sum else return 0.


Approach - 


Compute the sum of every subtree.

Store each subtree sum in a Map<Long, Integer> (frequency count).

After computing:

Let tot = total sum of tree.

If tot is even â†’ check if there exists a subtree whose sum is exactly tot/2.

Because removing the edge above that subtree divides the tree into two parts:

Subtree sum = tot/2

Remaining tree sum = tot - tot/2 = tot/2

âœ… Equal partition possible.

If tot == 0, then at least two different subtrees must have sum 0,
 so that cutting one edge still leaves another part with sum 0.



Time Complexity: O(N) â†’ visits each node once.

Space Complexity: O(N) â†’ hashmap storing all subtree sums.


Code - 

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

public int solve(TreeNode a) {
        Map < Long, Integer > map = new HashMap < > ();
        long tot = populate(a, map);
        // since total sum can also be zero
        if (tot == 0) 
            return map.getOrDefault(tot, 0) > 1 ? 1 : 0;
        return tot % 2 == 0 && map.containsKey(tot / 2) ? 1 : 0;
    }
    public long populate(TreeNode a, Map < Long, Integer > map) {
        if (a == null) 
            return 0;
        long sum = a.val + populate(a.left, map) + populate(a.right, map);
        map.put(sum, map.getOrDefault(sum, 0) + 1);
        return sum;
    }
}


Q - Sum binary tree or not


Problem Description

Given a binary tree. Check whether the given tree is a Sum-binary Tree or not.

Sum-binary Tree is a Binary Tree where the value of a every node is equal to sum of the nodes present in its left subtree and right subtree.

An empty tree is Sum-binary Tree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.

Return 1 if it sum-binary tree else return 0.



Problem Constraints

1 <= length of the array <= 100000

0 <= node values <= 50



Input Format

The only argument given is the root node of tree A.



Output Format

Return 1 if it is sum-binary tree else return 0.


Appraoch - 

To verify this, we need postorder traversal (left â†’ right â†’ root).

At each node, we must calculate:

The sum of its left subtree.

The sum of its right subtree.

Check if node.val == leftSum + rightSum.

If this condition fails anywhere, the whole tree is not a Sum Tree.

Efficient Approach

Instead of separately computing subtree sums multiple times (which could lead to O(n^2)), we should do it in one traversal:

Define a recursive function that:

Returns the sum of the subtree rooted at the current node if it is a Sum Tree.

Returns -1 if the subtree is not a Sum Tree.

While traversing:

If node is null â†’ return 0.

If node is a leaf â†’ return node.val.

Recursively get left and right subtree sums.

If either is -1 â†’ bubble up -1.

Check: node.val == leftSum + rightSum.

If true â†’ return node.val + leftSum + rightSum (total sum).

Else â†’ return -1.

At the end, if the result is -1, return 0, else 1.


Code - 


 public int solve(TreeNode A) {

        return isSumTree(A) != -1 ? 1:0;
    }

    public int isSumTree(TreeNode A){

        if( A == null) return 0;

        if(A.left == null && A.right == null){
            return A.val;
        }

        int leftSum = isSumTree(A.left);
        int rightSum = isSumTree(A.right);

        // propogate the failure 
        if( leftSum == -1 || rightSum == -1) return -1;

        if( A.val == leftSum+rightSum){
            return A.val + leftSum +rightSum;
        }else{
            return -1;
        }
    }


Q -  Level Order

Problem Description

Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).



Problem Constraints

1 <= number of nodes <= 105



Input Format

First and only argument is root node of the binary tree, A.



Output Format

Return a 2D integer array denoting the level order traversal of the given binary tree.


Approach - 

What below code is doing (Big Picture)

The goal is to get all nodes level by level (like BFS),
but instead of using an iterative queue-based BFS,
this code uses DFS (recursion) while keeping track of the current level.

ðŸ§© Key Idea

When you do a recursive traversal:

You can pass the level number (depth) as a parameter.

For each node:

Add its value to a list corresponding to that level.

Recurse for its left and right children with level + 1.

So effectively, the recursion â€œcollectsâ€ all nodes belonging to the same level inside a HashMap<Integer, ArrayList<Integer>>.


Code - 

public class Solution {

    HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();

    public int[][] solve(TreeNode A) {

        if(A == null){
            return null;
        }

        levelOrderTraversal(A, 0);

        int n = hm.size();

        int[][] ans = new int[n][];

        for(int i : hm.keySet() ){

            ArrayList<Integer> temp2 = hm.get(i);

            ans[i] = new int[temp2.size()];

            int k=0;

            for( int j : temp2){
                ans[i][k++] = j;
            }
        }

        return ans;
    }

    public void levelOrderTraversal(TreeNode A, int level){

        if( A == null){
            return;
        }

        ArrayList<Integer> temp = hm.getOrDefault(level, new ArrayList<Integer>());
        temp.add(A.val);
        hm.put(level, temp);

        levelOrderTraversal(A.left, level+1);
        levelOrderTraversal(A.right, level+1);
    }
}



Q - Balanced Binary Tree

Problem Description

Given a root of binary tree A, determine if it is height-balanced.

A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.



Problem Constraints

1 <= size of tree <= 100000



Input Format

First and only argument is the root of the tree A.



Output Format

Return 0 / 1 ( 0 for false, 1 for true ) for this problem.


Approach - 


BF - 

Check height of balanced condition for each node 
	1) Height of left subtree
	2) Height of right subtree
	

boolean isBalanced( Node root){

if( root == null ) return true;

int heightDiff = getHEight( root.left) - getHEight(root.right);

if( abs(heightDiff) > 1) return false;

return isBalanced( root.left) && isBalanced( root.right);

}

TC - O(nlogn) - the reason behind logn - when we check for left subtree and right subtree height we divide the tree in two halves and then check the if it balanced.


Optimized Approach (O(N)) â€” Single Traversal

We can check balance and height in one recursion.

Core Idea

For every node:

Recursively get the height of its left and right subtrees.

If either subtree is unbalanced, return -1.

If the height difference > 1, return -1 (mark unbalanced).

Otherwise, return the actual height of this node â†’
1 + max(leftHeight, rightHeight).

At the end:

If any recursive call returned -1, tree is unbalanced.

Otherwise, itâ€™s balanced.


Code - 


public class Solution {
    public int isBalanced(TreeNode A) {
        return checkBalance(A) != -1 ? 1 :0;
    }

    public int checkBalance( TreeNode node ){

        if( node == null ){
            return 0;
        }

        int leftHeight = checkBalance(node.left);

        if(leftHeight == -1) return -1;

        int rightHeight = checkBalance(node.right);

        if(rightHeight == -1) return -1;

        if( Math.abs( rightHeight - leftHeight) > 1) return -1;

        return 1 + Math.max(leftHeight, rightHeight);
    }
}


Q - Right View of Binary tree


Problem Description

Given a binary tree of integers denoted by root A. Return an array of integers representing the right view of the Binary tree.

Right view of a Binary Tree is a set of nodes visible when the tree is visited from Right side.



Problem Constraints

1 <= Number of nodes in binary tree <= 100000

0 <= node values <= 10^9



Input Format

First and only argument is head of the binary tree A.



Output Format

Return an array, representing the right view of the binary tree.


Approach - 



BF - 

We need rightomst node in each level, so find out level order traversal and return right side nodes.

TC - O(n)
SC - O(n)


Optimized - 

use Pre order traversal but visit right node before left.

DFS Steps:

Maintain a variable level.

When you first reach a new level, add the nodeâ€™s value to the result.

Always recurse to the right child first, then the left.



Code - 

public class Solution {
    public int[] solve(TreeNode A) {

        ArrayList<Integer> result = new ArrayList<Integer>();
        rightViewBS(A, 0, result);

        int[] ans = new int[result.size()];

        for( int i=0; i<result.size(); i++){
            ans[i] = result.get(i);
        }
        return ans;
    }

    public void rightViewBS( TreeNode node, int level, ArrayList<Integer> result){

        if( node == null){
            return;
        }

        if(level == result.size()){
            result.add(node.val);
        }

        rightViewBS(node.right, level+1, result);
        rightViewBS(node.left, level +1, result);
    }
}


Q - Binary Tree From Inorder And Postorder


Problem Description

Given the inorder and postorder traversal of a tree, construct the binary tree.



NOTE: You may assume that duplicates do not exist in the tree.





Problem Constraints

1 <= number of nodes <= 105



Input Format

First argument is an integer array A denoting the inorder traversal of the tree.

Second argument is an integer array B denoting the postorder traversal of the tree.



Output Format

Return the root node of the binary tree.



Example Input

Input 1:

 A = [2, 1, 3]
 B = [2, 3, 1]
Input 2:

 A = [6, 1, 3, 2]
 B = [6, 3, 2, 1]


 Appraoch -



Step 1ï¸âƒ£ â€” Root Identification

The last element in postorder is always the root.

From example: 3 is root.

Step 2ï¸âƒ£ â€” Partition Inorder Array

Find that root (3) in inorder array.

Inorder = [9, 3, 15, 20, 7]

Everything to the left of 3 â†’ left subtree

Everything to the right of 3 â†’ right subtree

Left inorder  = [9]
Right inorder = [15, 20, 7]

Step 3ï¸âƒ£ â€” Partition Postorder Array

Now, we must figure out how much of postorder belongs to left and right subtrees.

Left subtree has 1 element ([9])

Right subtree has 3 elements ([15, 7, 20])

So, in postorder (excluding the last element, which is root):

Postorder = [9, 15, 7, 20, 3]
Left postorder  = [9]
Right postorder = [15, 7, 20]

Step 4ï¸âƒ£ â€” Recurse

Now recursively build:

Left subtree from (left inorder, left postorder)

Right subtree from (right inorder, right postorder)

 Algorithm

Maintain a global index for postorder traversal (starting from last element).

Use a HashMap to quickly find the index of any element in inorder.

Build the tree recursively by:

Picking the current root from postorder.

Finding it in inorder.

Building right subtree first (because postorder is Leftâ€“Rightâ€“Root, we move from end).


Code - 

public class Solution {

    int postIndex;
    HashMap<Integer, Integer> inOrderMap;


    public TreeNode buildTree(int[] A, int[] B) {

        // if(A.length == 1){
        //     TreeNode node = new TreeNode(A[0]);
        //     return node;
        // }

        int n= A.length;

        postIndex = n-1;

        inOrderMap = new HashMap<>();

        for( int i=0; i<n; i++){
            inOrderMap.put(A[i], i);
        }

        return build(A, B, 0, n-1 );
    }

    public TreeNode build( int[] inorder, int[]postorder, int startIdx, int endIdx){

        if( startIdx > endIdx || postIndex < 0){
            return null;
        }

        // root from postorder
        int rootVal = postorder[postIndex--];

        TreeNode node = new TreeNode(rootVal);

        // finding root node in inorder 
        int index = inOrderMap.get(rootVal);

        // building right subtree first as we are moving from right to left in postorder array.
        node.right = build( inorder, postorder, index + 1, endIdx);
        node.left = build(inorder, postorder, startIdx, index-1);

        return node;
    }

}



Q - Binary Tree From Inorder And Preorder


Problem Description

Given preorder and inorder traversal of a tree, construct the binary tree.

NOTE: You may assume that duplicates do not exist in the tree.



Problem Constraints

1 <= number of nodes <= 105



Input Format

First argument is an integer array A denoting the preorder traversal of the tree.

Second argument is an integer array B denoting the inorder traversal of the tree.



Output Format

Return the root node of the binary tree.



Example Input

Input 1:

 A = [1, 2, 3]
 B = [2, 1, 3]
Input 2:

 A = [1, 6, 2, 3]
 B = [6, 1, 3, 2]


 Approach - 


 Core Intuition

In preorder traversal:

Root is always the first element.


In inorder traversal:

All nodes to the left of Root â†’ Left Subtree
All nodes to the right of Root â†’ Right Subtree


So:

Use preorder to know which node to pick next as root.

Use inorder to know where that node divides left and right subtrees.

Recurse for left and right portions.

ðŸ§® Step-by-Step Example

Say:

Preorder (A) = [3, 9, 20, 15, 7]
Inorder  (B) = [9, 3, 15, 20, 7]


We want to rebuild:

        3
       / \
      9  20
         / \
        15  7

Step 1ï¸âƒ£ â€” Start with Preorder

First element in preorder = 3 â†’ this is root.

Step 2ï¸âƒ£ â€” Find in Inorder

In inorder = [9, 3, 15, 20, 7]

Root (3) is at index 1.

Left of 3 â†’ [9] â†’ left subtree

Right of 3 â†’ [15, 20, 7] â†’ right subtree

Step 3ï¸âƒ£ â€” Recurse

Next preorder element â†’ 9 â†’ left subtreeâ€™s root.

Then â†’ 20 â†’ right subtreeâ€™s root.

Continue recursively using inorder splits.


Code - 


public class Solution {

    int preIndex;
    HashMap<Integer, Integer> inorderMap;

    public TreeNode buildTree(int[] A, int[] B) {

        int n = B.length;
        preIndex=0;

        inorderMap = new HashMap<>();

        for( int i =0; i<n; i++){
            inorderMap.put(B[i], i);
        }

        return build(A, B, 0, n-1);
    }

    public TreeNode build(int[] preOrder, int[] inOrder, int startIdx, int endIdx){

        if(startIdx > endIdx || preIndex >= preOrder.length){
            return null;
        }

        int rootVal = preOrder[preIndex++];

        int index = inorderMap.get(rootVal);

        TreeNode node = new TreeNode(rootVal);

        node.left = build( preOrder, inOrder, startIdx, index-1);
        node.right = build( preOrder, inOrder, index+1, endIdx);

        return node;
    }
}


Q - Serialize Binary Tree

Problem Description

Given the root node of a Binary Tree denoted by A. You have to Serialize the given Binary Tree in the described format.

Serialize means encode it into a integer array denoting the Level Order Traversal of the given Binary Tree.

NOTE:

In the array, the NULL/None child is denoted by -1.
For more clarification check the Example Input.


Problem Constraints

1 <= number of nodes <= 105



Input Format

Only argument is a A denoting the root node of a Binary Tree.



Output Format

Return an integer array denoting the Level Order Traversal of the given Binary Tree.


Appraoch - 


Do level order traversal and store -1 for null nodes.

Code - 

public class Solution {

    int totalElements;
    HashMap<Integer, ArrayList<Integer>> lvlOrderMap;

    public int[] solve(TreeNode A) {

        lvlOrderMap = new HashMap<>();
        totalElements=0;

        levelOrder(A, 0);

        int[] ans = new int[totalElements];

        int k=0;

        for( int i=0; i<lvlOrderMap.size(); i++){

            for( int a: lvlOrderMap.get(i)){
                ans[k++] = a;
            }
        }

        return ans;

    }

    public void levelOrder(TreeNode node, int level){
        
        totalElements++;

        if( node == null){

            ArrayList<Integer> levelNodes = lvlOrderMap.getOrDefault(level, new ArrayList<Integer>());
            levelNodes.add(-1);
            lvlOrderMap.put(level, levelNodes);
            return;
        }

        ArrayList<Integer> levelNodes = lvlOrderMap.getOrDefault(level, new ArrayList<Integer>());

        levelNodes.add(node.val);
        lvlOrderMap.put(level, levelNodes);

        levelOrder(node.left, level+1);
        levelOrder(node.right, level+1);
    }
}

Q - Deserialize Binary Tree


Problem Description

You are given an integer array A denoting the Level Order Traversal of the Binary Tree.

You have to Deserialize the given Traversal in the Binary Tree and return the root of the Binary Tree.

NOTE:





In the array, the NULL/None child is denoted by -1.
For more clarification check the Example Input.


Problem Constraints

1 <= number of nodes <= 105

-1 <= A[i] <= 105



Input Format

Only argument is an integer array A denoting the Level Order Traversal of the Binary Tree.



Output Format

Return the root node of the Binary Tree.



Example Input

Input 1:

 A = [1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1]
Input 2:

 A = [1, 2, 3, 4, 5, -1, 6, -1, -1, -1, -1, -1, -1]


 Appraoch - 

 We reconstruct the tree level by level, exactly as described in the array.

Start with the root node, which is always the first element of the array.

Use a queue to keep track of nodes whose children are not yet assigned.

Iterate through the array, and for each node from the queue:

Assign its left child using the next array element.

Assign its right child using the next array element.

Add the non-null children to the queue so that we can process their children in the next iterations.

Stop when the array is fully processed.

Time Complexity: O(n)

Each element in the array is visited exactly once.

Space Complexity: O(n)

The queue can hold up to all nodes at the last level of the tree.


Code - 


public TreeNode solve(int[] A) {

      if (A.length == 0) return null;

        TreeNode root = new TreeNode(A[0]);
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);

        int i = 1;

        while (!q.isEmpty() && i < A.length) {
            TreeNode curr = q.poll(); // remove head of queue

            if (curr == null) continue;

            // left child
            if (i < A.length) {
                int val_left = A[i++];
                if (val_left == -1) {
                    curr.left = null;
                } else {
                    curr.left = new TreeNode(val_left);
                    q.add(curr.left);
                }
            }

            // right child
            if (i < A.length) {
                int val_right = A[i++];
                if (val_right == -1) {
                    curr.right = null;
                } else {
                    curr.right = new TreeNode(val_right);
                    q.add(curr.right);
                }
            }
        }

        return root;

}


