Q - Equal Tree Partition

Given a binary tree A. Check whether it is possible to partition the tree to two trees which have equal sum of values after removing exactly one edge on the original tree.

Problem Constraints

1 <= size of tree <= 100000

0 <= value of node <= 109

Input Format

First and only argument is head of tree A.

Output Format

Return 1 if the tree can be partitioned into two trees of equal sum else return 0.


Approach - 


Compute the sum of every subtree.

Store each subtree sum in a Map<Long, Integer> (frequency count).

After computing:

Let tot = total sum of tree.

If tot is even → check if there exists a subtree whose sum is exactly tot/2.

Because removing the edge above that subtree divides the tree into two parts:

Subtree sum = tot/2

Remaining tree sum = tot - tot/2 = tot/2

✅ Equal partition possible.

If tot == 0, then at least two different subtrees must have sum 0,
 so that cutting one edge still leaves another part with sum 0.



Time Complexity: O(N) → visits each node once.

Space Complexity: O(N) → hashmap storing all subtree sums.


Code - 

/**
 * Definition for binary tree
 * class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) {
 *      val = x;
 *      left=null;
 *      right=null;
 *     }
 * }
 */
public class Solution {

public int solve(TreeNode a) {
        Map < Long, Integer > map = new HashMap < > ();
        long tot = populate(a, map);
        // since total sum can also be zero
        if (tot == 0) 
            return map.getOrDefault(tot, 0) > 1 ? 1 : 0;
        return tot % 2 == 0 && map.containsKey(tot / 2) ? 1 : 0;
    }
    public long populate(TreeNode a, Map < Long, Integer > map) {
        if (a == null) 
            return 0;
        long sum = a.val + populate(a.left, map) + populate(a.right, map);
        map.put(sum, map.getOrDefault(sum, 0) + 1);
        return sum;
    }
}


Q - Sum binary tree or not


Problem Description

Given a binary tree. Check whether the given tree is a Sum-binary Tree or not.

Sum-binary Tree is a Binary Tree where the value of a every node is equal to sum of the nodes present in its left subtree and right subtree.

An empty tree is Sum-binary Tree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTree.

Return 1 if it sum-binary tree else return 0.



Problem Constraints

1 <= length of the array <= 100000

0 <= node values <= 50



Input Format

The only argument given is the root node of tree A.



Output Format

Return 1 if it is sum-binary tree else return 0.


Appraoch - 

To verify this, we need postorder traversal (left → right → root).

At each node, we must calculate:

The sum of its left subtree.

The sum of its right subtree.

Check if node.val == leftSum + rightSum.

If this condition fails anywhere, the whole tree is not a Sum Tree.

Efficient Approach

Instead of separately computing subtree sums multiple times (which could lead to O(n^2)), we should do it in one traversal:

Define a recursive function that:

Returns the sum of the subtree rooted at the current node if it is a Sum Tree.

Returns -1 if the subtree is not a Sum Tree.

While traversing:

If node is null → return 0.

If node is a leaf → return node.val.

Recursively get left and right subtree sums.

If either is -1 → bubble up -1.

Check: node.val == leftSum + rightSum.

If true → return node.val + leftSum + rightSum (total sum).

Else → return -1.

At the end, if the result is -1, return 0, else 1.


Code - 


 public int solve(TreeNode A) {

        return isSumTree(A) != -1 ? 1:0;
    }

    public int isSumTree(TreeNode A){

        if( A == null) return 0;

        if(A.left == null && A.right == null){
            return A.val;
        }

        int leftSum = isSumTree(A.left);
        int rightSum = isSumTree(A.right);

        // propogate the failure 
        if( leftSum == -1 || rightSum == -1) return -1;

        if( A.val == leftSum+rightSum){
            return A.val + leftSum +rightSum;
        }else{
            return -1;
        }
    }


    