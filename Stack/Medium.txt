Q - Check two bracket expressions


Problem Description

Given two strings A and B. Each string represents an expression consisting of lowercase English alphabets, '+', '-', '(' and ')'.


The task is to compare them and check if they are similar. If they are identical, return 1 else, return 0.

NOTE: It may be assumed that there are at most 26 operands from â€˜aâ€™ to â€˜zâ€™, and every operand appears only once.




Problem Constraints

1 <= length of the each String <= 100



Input Format

The given arguments are string A and string B.



Output Format

Return 1 if they represent the same expression else return 0.



Example Input

Input 1:

 A = "-(a+b+c)"
 B = "-a-b-c"
Input 2:

 A = "a-b-(c-d)"
 B = "a-b-c-d"


Example Output

Output 1:

 1
Output 2:

 0


Example Explanation

Explanation 1:

 The expression "-(a+b+c)" can be written as "-a-b-c" which is equal as B. 
Explanation 2:

 Both the expression are different.


 Approach - 

 
The trick here is to simplify both expression by removing brackets and properly adjusting signs. Only then can we compare them letter by letter.

We will traverse the string from left to right and use stack to remember if we are under + or -.

we will keep a sign stack to track current (+ or -), every tiem we hit (, we combine current sign with the top of stack and push it. when we hit ')', we pop the sign.

The stack help us remember the sign context. When - comes before a bracket, it flips the sign of everything inside. We simulate this by pushing flip sign onto the stack and popping it out when bracket ends.



Code - 

public class Solution {
    public int solve(String A, String B) {

        String flattenedA = flatten(A);
        String flattenedB = flatten(B);

        return flattenedA.equals(flattenedB) ? 1:0;
    }

    private String flatten(String A){
        Stack<Character> signStack = new Stack<>();

        signStack.push('+');
        char currentSign = '+';

        Map<Character, Integer> variableMap = new HashMap<>();

        int i=0;

        while( i < A.length()){

            char ch = A.charAt(i);

            if( ch == '+' || ch == '-'){
                currentSign = ch;
                i++;
            }else if( ch == '('){

                // combine sign with top stack
                char top = signStack.peek();
                char effectiveSign = combineSign(top, currentSign);

                signStack.push(effectiveSign);

                currentSign = '+'; // reset for next inner expression
                i++;
            }else if( ch ==')'){
                signStack.pop();
                i++;
            }else if( Character.isLetter(ch)){
                char top = signStack.peek();
                char effectiveSign = combineSign(top, currentSign);

                // update variable map with net sign 
                // +1 for positive and -1 for negative

                variableMap.put( ch, effectiveSign == '+' ? 1: -1);
                i++;
            }else {
                i++;
            }
        }

            StringBuilder sb = new StringBuilder();

            for( char ch ='a'; ch <= 'z'; ch++){
                if(variableMap.containsKey(ch)){

                    sb.append(ch).append(":").append(variableMap.get(ch)).append(",");
                }
            }

            return sb.toString();
        
    }

    private static char combineSign(char a, char b){
        if( a==b) return '+';
        return '-';
    }
}


Q - Infix to Postfix

Problem Description

Given string A denoting an infix expression. Convert the infix expression into a postfix expression.


String A consists of ^, /, *, +, -, (, ) and lowercase English alphabets where lowercase English alphabets are operands and ^, /, *, +, - are operators.

Find and return the postfix expression of A.

NOTE:

^ has the highest precedence.
/ and * have equal precedence but greater than + and -.
+ and - have equal precedence and lowest precedence among given operators.



Problem Constraints

1 <= length of the string <= 500000



Input Format

The only argument given is string A.



Output Format

Return a string denoting the postfix conversion of A.



Example Input

Input 1:

 A = "x^y/(a*z)+b"
Input 2:

 A = "a+b*(c^d-e)^(f+g*h)-i"


Example Output

Output 1:

 "xy^az*/b+"
Output 2:

 "abcd^e-fgh*+^*+i-"


Example Explanation

Explanation 1:

 Ouput dentotes the postfix expression of the given input.


 Approach - 

 
In postfix the operators with higher precedence comes first than the operators with lower precedence.

Rules to convert an expression from infix to postfix - 

a to z characters - add it to the output.

( bracket - push parenthesis onto the stack.

^, /, *, +, - - if bracket is present or stack is empty push the operator onto stack else keep popping if the operator on top of the stack has higher or equal precedence than current operator and then push the operator on stack.

) bracket - pop till we get an open bracket.


repeat above expressions untill entire expression is scanned.

at the end pop all remaining operators from stack.



Code - 

public class Solution {
   
    public String solve(String A) {
        return infixToPostfix(A);
    }
    public int prec(char c) {
        if (c == '^')
            return 3;
        else if (c == '*' || c == '/')
            return 2;
        else if (c == '+' || c == '-')
            return 1;
        else
            return -1;
    }
    // Function to convert infix expression
    //to postfix expression
    public String infixToPostfix(String s) {
        Stack < Character > st = new Stack < Character > ();
        st.push('N');
        ArrayList < Character > ns = new ArrayList < Character > ();
        for (int i = 0; i < s.length(); i++) {
            char C = s.charAt(i);
            // If the scanned character is an operand, add it to output string.
            if ((C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z'))
                ns.add(C);
            // If the scanned character is an '(', push it to the stack.
            else if (C == '(')
                st.push('(');
            // If the scanned character is an ')', pop and to output string from the stack
            // until an '(' is encountered.
            else if (C == ')') {
                while (st.peek() != 'N' && st.peek() != '(') {
                    char c = st.peek();
                    st.pop();
                    ns.add(c);
                }
                if (st.peek() == '(') {
                    char c = st.peek();
                    st.pop();
                }
            }
            //If an operator is scanned
            else {
                while (st.peek() != 'N' && prec(C) <= prec(st.peek())) {
                    char c = st.peek();
                    st.pop();
                    ns.add(c);
                }
                st.push(C);
            }
        }
        //Pop all the remaining elements from the stack
        while (st.peek() != 'N') {
            char c = st.peek();
            st.pop();
            ns.add(c);
        }
        StringBuilder result = new StringBuilder(ns.size());
        for (Character c: ns) {
            result.append(c);
        }
        return result.toString();
    }
   
}

Q - Largest Rectangle in Histogram

Problem Description

Given an array of integers A.


A represents a histogram i.e A[i] denotes the height of the ith histogram's bar. Width of each bar is 1.

Find the area of the largest rectangle formed by the histogram.




Problem Constraints

1 <= |A| <= 100000


1 <= A[i] <= 10000




Input Format

The only argument given is the integer array A.



Output Format

Return the area of the largest rectangle in the histogram.



Example Input

Input 1:

 A = [2, 1, 5, 6, 2, 3]
Input 2:

 A = [2]


Example Output

Output 1:

 10
Output 2:

 2


Example Explanation

Explanation 1:


The largest rectangle has area = 10 unit. Formed by A[3] to A[4].

Explanation 2:


Largest rectangle has area 2.

Approach - 

find out the Nearest smaller on left and nearest smaller on right of the given array.

The nearest smaller on left and right will give the index of nearest smaller in the
array at that index and next to that nearest smaller index we will get the index
of element which is greater than nearest smaller and that will result in 
forming a rectangle with maximum possible area.

Code - 

public class Solution {
    public int largestRectangleArea(int[] A) {

        int[] NSR = NearestSmallerOnRight(A);
        int[] NSL = NearestSmallerOnLeft(A);

        int maxArea=0;

        int n= A.length;

        for( int i=0; i<n; i++){

            int height=A[i];
            int l=NSL[i];
            int r = NSR[i];

            int width = r-l-1;

            maxArea = Math.max(width * height, maxArea);
        }

        return maxArea;
    }

    public static int[] NearestSmallerOnRight(int[] A){

        int n = A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for( int i =n-1; i >= 0; i--){

            while( !st.isEmpty() && A[st.peek()] >= A[i]){
                st.pop();
            }

            if( st.isEmpty()){
                ans[i] = n;
            }else{
                ans[i] = st.peek();
            }

            st.push(i);
        }

        return ans;
    }

     public static int[] NearestSmallerOnLeft(int[] A){

        int n = A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for( int i =0; i<n; i++){   

            while( !st.isEmpty() && A[st.peek()] >= A[i]){
                st.pop();
            }

            if( st.isEmpty()){
                ans[i] = -1;
            }else{
                ans[i] = st.peek();
            }

            st.push(i);
        }

        return ans;
    }
}

Q - Nearest Smaller Element

Problem Description

Given an array A, find the nearest smaller element G[i] for every element A[i] in the array such that the element has an index smaller than i.


More formally,

G[i] for an element A[i] = an element A[j] such that

j is maximum possible AND

j < i AND

A[j] < A[i]

Elements for which no smaller element exist, consider the next smaller element as -1.




Problem Constraints

1 <= |A| <= 100000


-109 <= A[i] <= 109





Input Format

The only argument given is integer array A.



Output Format

Return the integar array G such that G[i] contains the nearest smaller number than A[i]. If no such element occurs G[i] should be -1.



Example Input

Input 1:


 A = [4, 5, 2, 10, 8]

Input 2:


 A = [3, 2, 1]



Example Output

Output 1:


 [-1, 4, -1, 2, 2]

Output 2:


 [-1, -1, -1]



Example Explanation

Explanation 1:


index 1: No element less than 4 in left of 4, G[1] = -1
index 2: A[1] is only element less than A[2], G[2] = A[1]
index 3: No element less than 2 in left of 2, G[3] = -1
index 4: A[3] is nearest element which is less than A[4], G[4] = A[3]
index 4: A[3] is nearest element which is less than A[5], G[5] = A[3]

Explanation 2:


index 1: No element less than 3 in left of 3, G[1] = -1
index 2: No element less than 2 in left of 2, G[2] = -1
index 3: No element less than 1 in left of 1, G[3] = -1


Approach - 

use stack to find the nearest smaller element on the left of the current index.

Code - 

public class Solution {
    public int[] prevSmaller(int[] A) {

        // nearest smaller on the left

        int n = A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for( int i=0; i<n; i++){

            int ele = A[i];

            while( !st.isEmpty() && A[st.peek()] >= ele ){
                st.pop();
            }

            if(st.isEmpty()){
                ans[i] = -1;
            }else{
                ans[i] = st.peek();
            }

            st.push(i);            
        }

        for(int i=0; i<n; i++){
            
            if(ans[i] != -1){
            ans[i] = A[ans[i]];
            }

        }
        return ans;
    }
}


Q - MAX and MIN

Problem Description

Given an array of integers A.


The value of an array is computed as the difference between the maximum element in the array and the minimum element in the array A.

Calculate and return the sum of values of all possible subarrays of A modulo 109+7.





Problem Constraints

1 <= |A| <= 100000


1 <= A[i] <= 1000000




Input Format

The first and only argument given is the integer array A.



Output Format

Return the sum of values of all possible subarrays of A modulo 109+7.



Example Input

Input 1:


 A = [1]

Input 2:


 A = [4, 7, 3, 8]



Example Output

Output 1:

 0
Output 2:

 26


Example Explanation

Explanation 1:

Only 1 subarray exists. Its value is 0.
Explanation 2:

value ( [4] ) = 4 - 4 = 0
value ( [7] ) = 7 - 7 = 0
value ( [3] ) = 3 - 3 = 0
value ( [8] ) = 8 - 8 = 0
value ( [4, 7] ) = 7 - 4 = 3
value ( [7, 3] ) = 7 - 3 = 4
value ( [3, 8] ) = 8 - 3 = 5
value ( [4, 7, 3] ) = 7 - 3 = 4
value ( [7, 3, 8] ) = 8 - 3 = 5
value ( [4, 7, 3, 8] ) = 8 - 3 = 5
sum of values % 10^9+7 = 26


Approach - 


BF - 

Try out all the subarrays.
MAintain two variables to track min and max of any subarray.

TC - O(n^2)
SC - O(1)


Optimization 1 - 

Instead of calculating value of each sub array we should - for each element of the array find its contribution to the total answer. 

value = max(array) - min( array)


ans = A[i] * ( count of subarrays it is max - count of subarrays where it is min)


Approach - 

Calculate the next greater element and previous greater element for each element in the array. Each element Ai is the maximum of all subarrays starting at (previous greater element)i + 1 to (next greater element)i - 1.

Similarly, the next smaller element and previous smaller element can be used for minimum values of subarrays

Time Complexity:- O(N)



Code - 

public class Solution {
    public int solve(int[] A) {

        int n = A.length;

            int[] nxtGrtOnLeft = nextGreaterElementOnLeft(A);
            int[] nxtSmlOnLeft = nextSmallerElementOnLeft(A);
            int[] nxtGrtOnRight = nextGreaterElementOnRight(A);
            int[] nxtSmlOnRight = nextSmallerElementOnRight(A);

        long grtTotal=0;

        int mod = 1000000007;

        for(int i =0; i < n; i++){

            int leftGrt = i - nxtGrtOnLeft[i];
            int rightGrt = nxtGrtOnRight[i] - i;

long count = (long) leftGrt * rightGrt;
grtTotal = (grtTotal + ((A[i] ) * 1L * count) % mod) % mod;
        }

        long smlTotal = 0;
        

        for(int i =0; i < n; i++){
            int leftSml = i - nxtSmlOnLeft[i];
            int rightSml = nxtSmlOnRight[i] - i;

long cnt = (long) leftSml * rightSml;
smlTotal = (smlTotal + ((A[i] ) * 1L * cnt) % mod) % mod;
        }

        return (int) (grtTotal - smlTotal + mod) %mod;

    }

    public static int[] nextGreaterElementOnLeft(int[] A){

        int n= A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<Integer>();

        for( int i=0; i<n; i++){

            int temp = A[i];

            while(!st.isEmpty() && A[st.peek()] <= temp){
                st.pop();
            }

            if(st.isEmpty()){
            ans[i] = -1;
            }else{
            ans[i] = st.peek();
            }

            st.push(i);
        }

        return ans;
    }

    public static int[] nextSmallerElementOnLeft(int[] A){

        int n = A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for(int i=0; i<n; i++){

            int temp = A[i];

            while( !st.isEmpty() && A[st.peek()] >= temp){
                st.pop();
            }

            if(st.isEmpty()){
                ans[i] = -1;
            }else{
                ans[i] = st.peek();
            }

            st.push(i);
        }
        return ans;
    }


    public static int[] nextGreaterElementOnRight(int[] A){

        int n= A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for(int i =n-1; i>=0; i--){

            int temp = A[i];

            while( !st.isEmpty() && A[st.peek()] < temp){
                st.pop();
            }

            if(st.isEmpty()){
                ans[i] = n;
            }else{
                ans[i] = st.peek();
            }
            st.push(i);
        }

        return ans;
    }

    public static int[] nextSmallerElementOnRight(int[] A){

        int n=A.length;

        int[] ans = new int[n];

        Stack<Integer> st = new Stack<>();

        for( int i = n-1; i>= 0; i--){
            int temp = A[i];

            while( !st.isEmpty() && A[st.peek()] > temp){
                st.pop();
            }

            if(st.isEmpty()){
                ans[i] = n;
            }else{
                ans[i] = st.peek();
            }

            st.push(i);
        }

        return ans;
    }
}


Q -  Next Greater


Problem Description

Given an array A, find the next greater element G[i] for every element A[i] in the array.
The next greater element for an element A[i] is the first greater element on the right side of A[i] in the array, A.


More formally:

G[i] for an element A[i] = an element A[j] such that 
    j is minimum possible AND 
    j > i AND
    A[j] > A[i]
Elements for which no greater element exists, consider the next greater element as -1.









Problem Constraints

1 <= |A| <= 105


1 <= A[i] <= 107




Input Format

The first and the only argument of input contains the integer array, A.



Output Format

Return an integer array representing the next greater element for each index in A.



Example Input

Input 1:

 A = [4, 5, 2, 10] 
Input 2:

 A = [3, 2, 1] 



Example Output

Output 1:

 [5, 10, 10, -1] 
Output 2:

 [-1, -1, -1] 


Example Explanation

Explanation 1:

For 4, the next greater element towards its right is 5.
For 5 and 2, the next greater element towards their right is 10.
For 10, there is no next greater element towards its right.
Explanation 2:

As the array is in descending order, there is no next greater element for all the elements. 

Approach - Here we need to find the next greater element on right.

Code - 

public class Solution {
    public int[] nextGreater(int[] A) {

        int n= A.length;

        Stack<Integer> st = new Stack<>();
        int ans[] = new int[n];

        for( int i = n-1; i>= 0; i--){

            int temp = A[i];

            while( !st.isEmpty() && st.peek() <= temp){
                st.pop();
            }

            if( st.isEmpty()){
                ans[i] = -1;
            }else{
                ans[i] = st.peek();
            }

            st.push(temp);
        }

        return ans;
    }
}


Q - Sort stack using another stack


Problem Description

Given a stack of integers A, sort it using another stack.

Return the array of integers after sorting the stack using another stack.



Problem Constraints

1 <= |A| <= 5000


0 <= A[i] <= 109




Input Format

The only argument is a stack given as an integer array A.



Output Format

Return the array of integers after sorting the stack using another stack.



Example Input

Input 1:

 A = [5, 4, 3, 2, 1]
Input 2:

 A = [5, 17, 100, 11]


Example Output

Output 1:

 [1, 2, 3, 4, 5]
Output 2:

 [5, 11, 17, 100]


Example Explanation

Explanation 1:

 Just sort the given numbers.
Explanation 2:

 Just sort the given numbers.


 Approach - 

 Create a temporary stack say B.

While input stack is not empty:
1. pop an element from input stack calls it x.
2. while the temporary stack is not empty and top of the temporary stack is greater than x pop from the temporary stack and push it into input stack.
3. push x in the temporary stack.

The sorted numbers are in the temporary stack.

Worst case time complexity O(n^2).

Code - 

public class Solution {
    public int[] solve(int[] A) {

        int n=A.length;
        Stack<Integer> st = new Stack<>();
        Stack<Integer> st2 = new Stack<>();

        int[] ans = new int[n];

        for( int i=0; i<n; i++){

            int temp = A[i];
            
            while( !st.isEmpty() && st.peek() <= temp){
                st2.push(st.pop());
            }

            st.push(temp);

        while(!st2.isEmpty()){
            st.push(st2.pop());
        }


        }



        for( int i=0; i < n; i++){
            if(!st.isEmpty())
            ans[i] = st.pop();
        }

        return ans;

    }
}


Q - Max Rectangle in Binary Matrix

Problem Description

Given a 2-D binary matrix A of size N x M filled with 0's and 1's, find the largest rectangle containing only ones and return its area.




Problem Constraints

1 <= N, M <= 100



Input Format

The first argument is a 2-D binary array A.



Output Format

Return an integer denoting the area of the largest rectangle containing only ones.



Example Input

Input 1:

 A = [
       [1, 1, 1]
       [0, 1, 1]
       [1, 0, 0] 
     ]
Input 2:

 A = [
       [0, 1, 0]
       [1, 1, 1]
     ] 


Example Output

Output 1:

 4
Output 2:

 3


Example Explanation

Explanation 1:


 As the max area rectangle is created by the 2x2 rectangle created by (0, 1), (0, 2), (1, 1) and (1, 2).
Explanation 2:

 As the max area rectangle is created by the 1x3 rectangle created by (1, 0), (1, 1) and (1, 2).


 Approach - 

 Brute Force - 

The rectangle is defined by two rows and two columns:

Top-left corner â†’ (r1, c1)

Bottom-right corner â†’ (r2, c2)

So, in brute force, we can try all possible rectangles and check if they are filled entirely with 1s.

Steps

Enumerate all possible pairs of rows and columns:

Choose r1 (top row) â†’ from 0 to N-1

Choose c1 (left column) â†’ from 0 to M-1

Choose r2 (bottom row) â†’ from r1 to N-1

Choose c2 (right column) â†’ from c1 to M-1

That defines one rectangle.

Check if this rectangle is valid:

Iterate over all cells inside (r1, c1) to (r2, c2).

If all are 1s â†’ rectangle is valid.

Calculate area:

area=(r2âˆ’r1+1)Ã—(c2âˆ’c1+1)

Keep track of maximum area found.

Time Complexity

Number of ways to choose rectangles:

ð‘‚(ð‘^2 Ã— ð‘€^2)

For each rectangle, checking all cells:

O(NÃ—M)

Total complexity:

ð‘‚(ð‘^3 Ã— ð‘€^3)


Optimization - 

Key Idea

If you think about it:

Each row of the matrix can be treated as the base of a histogram.

The histogram height at each column represents the number of consecutive 1â€™s up to that row.

Then, for each row, the problem reduces to finding the largest rectangle area in a histogram (which we already know how to do in O(M) using stacks).

Step-by-Step
Step 1: Build histogram heights

Create an array heights[M] (same width as the matrix).

Start from row 0, fill heights with 1 where matrix cell is 1.

For every next row:

If A[r][c] == 1 â†’ heights[c] += 1

Else â†’ heights[c] = 0

So, heights[c] always represents the **continuous streak of 1â€™s in column c up to row r.

Step 2: Largest Rectangle in Histogram (LRH)

For each rowâ€™s heights, compute the maximum rectangle area in that histogram.

This is done using the Next Smaller Element (NSE) left & right approach with stacks in O(M).

Formula for area:

area
=
height[i]
Ã—
(
right[i]
âˆ’
left[i]
âˆ’
1
)
area=height[i]Ã—(right[i]âˆ’left[i]âˆ’1)
Step 3: Track global maximum

Process all rows one by one, compute histogram max area for each row, update the answer.

Example

Matrix:

[
  [0, 1, 0],
  [1, 1, 1]
]


Row 0 â†’ heights = [0, 1, 0] â†’ max area = 1

Row 1 â†’ update heights:

If cell=1 â†’ add 1

If cell=0 â†’ reset to 0
So, heights = [1, 2, 1]
Largest Rectangle in Histogram = 3

Answer = 3 âœ…

Time Complexity

For each of N rows â†’ build/update histogram in O(M)

For each histogram â†’ LRH in O(M)

Total = O(N * M) (much faster than brute force O(N^3 * M^3))

Dry run with an example - 

Matrix:

[
  [1, 1, 1],
  [0, 1, 1],
  [1, 0, 0]
]


Weâ€™ll build heights[] row by row and compute the largest rectangle in histogram at each step.

Row 0 â†’ [1, 1, 1]

Build histogram:

heights = [1, 1, 1]


Largest Rectangle in Histogram (LRH):

Rectangles possible: 1x3, 1x2, 1x1.

Max area = 3.

So far â†’ maxArea = 3

Row 1 â†’ [0, 1, 1]

Update histogram:

Column 0: 0 â†’ reset â†’ 0

Column 1: 1 â†’ add 1 â†’ 2

Column 2: 1 â†’ add 1 â†’ 2

heights = [0, 2, 2]


LRH:

At col1 â†’ height=2, width=2 â†’ area=4 âœ…

At col2 â†’ height=2, width=1 â†’ area=2

At col0 â†’ height=0, area=0

Max area = 4

So far â†’ maxArea = 4

Row 2 â†’ [1, 0, 0]

Update histogram:

Column 0: 1 â†’ add 1 â†’ 1

Column 1: 0 â†’ reset â†’ 0

Column 2: 0 â†’ reset â†’ 0

heights = [1, 0, 0]


LRH:

At col0 â†’ height=1, width=1 â†’ area=1

Others = 0

Max area = 1

So far â†’ maxArea = max(4,1) = 4

Final Answer = 4 âœ…

This matches the expected output from your example:

[
  [1, 1, 1]
  [0, 1, 1]
  [1, 0, 0]
]
â†’ Max rectangle area = 4


âœ¨ So the histogram evolves like this:

Row 0: [1, 1, 1] â†’ area = 3  
Row 1: [0, 2, 2] â†’ area = 4  
Row 2: [1, 0, 0] â†’ area = 1  


ðŸ‘‰ Global maximum = 4

Code  - 

public class Solution {
    public int maximalRectangle(int[][] A) {

 if (A.length == 0) return 0;

        int n = A.length, m = A[0].length;
        int[] heights = new int[m];
        int maxArea = 0;

        for (int i = 0; i < n; i++) {
            // Build histogram
            for (int j = 0; j < m; j++) {
                if (A[i][j] == 1) heights[j] += 1;
                else heights[j] = 0;
            }
            // Find max rectangle in histogram
            maxArea = Math.max(maxArea, largestRectangleInHistogram(heights));
        }
        return maxArea;

    }

    private int largestRectangleInHistogram(int[] heights) {
        int n = heights.length;
        Stack<Integer> st = new Stack<>();
        int maxArea = 0;

        for (int i = 0; i <= n; i++) {
            int h = (i == n ? 0 : heights[i]);
            while (!st.isEmpty() && h < heights[st.peek()]) {
                int height = heights[st.pop()];
                int width = st.isEmpty() ? i : i - st.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            st.push(i);
        }
        return maxArea;
    }
}


Q - Minimum Insertions to Balance a Parentheses String

Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:

Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.
Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.
In other words, we treat '(' as an opening parenthesis and '))' as a closing parenthesis.

For example, "())", "())(())))" and "(())())))" are balanced, ")()", "()))" and "(()))" are not balanced.
You can insert the characters '(' and ')' at any position of the string to balance it if needed.

Return the minimum number of insertions needed to make s balanced.

 

Example 1:

Input: s = "(()))"
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be "(())))" which is balanced.
Example 2:

Input: s = "())"
Output: 0
Explanation: The string is already balanced.
Example 3:

Input: s = "))())("
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.
 

Constraints:

1 <= s.length <= 105
s consists of '(' and ')' only.


Code - 

BF - 

 public int minInsertions(String s) {
        
        Stack<Character> stack = new Stack<>();
        int insertions =0;
        int i=0;
        int n= s.length();

        while( i < n){

            char c = s.charAt(i);

            if( c == '('){
                stack.push(c);
                i++;
            }else {
                if( i+1 < n && s.charAt(i+1) == ')'){
                    // we have 2 close brackets

                    if(stack.isEmpty()){
                        insertions++;
                    }else{
                        stack.pop(); // balanced match
                    }

                    i += 2;
                } else {

                    // single ')'
                    if( stack.isEmpty()){
                        insertions++; // inserting '('
                    }else{
                        stack.pop();
                    }

                    insertions++; // inserting second ')'
                    i++;
                }
            }
        }

        // handle leftover '('
        while( !stack.isEmpty()){
            stack.pop();
            insertions+=2; // each '(' needs '))'
        }

        return insertions;
    }

Optimised - 

Optimized Logic

We only need two things:

1. need

How many ')' we need to complete all open '('.

2. insertions

How many insertions we are forced to make.

Rules

When we see '('
â†’ we need 2 extra )
â†’ need += 2

If need becomes odd
â†’ means we have unpaired single ')'
â†’ so insert one ')'
â†’ insertions++
â†’ need-- (to make it even again)

When we see ')'
â†’ need-- (because this closes something)

If need becomes negative
â†’ means we had more ) than we should
â†’ insert '('
â†’ insertions++
â†’ make need = 1 (because '(' needs two ) and we already saw one ))

At the end
â†’ we still need need more )
â†’ add need to insertions

Code - 

public int minInsertions(String s) {
    int insertions = 0; // number of insertions needed
    int need = 0;       // how many ')' we need

    for (char c : s.toCharArray()) {

        if (c == '(') {
            need += 2;

            // if need is odd, we have to insert one ')'
            if (need % 2 == 1) {
                insertions++;
                need--; // make it even
            }

        } else { // c == ')'
            need--;

            if (need < 0) {
                // we need an '(' before this ')'
                insertions++;
                need = 1; // because '(' needs 2 ')', but we already have one ')'
            }
        }
    }

    return insertions + need; // add required right parentheses
}

