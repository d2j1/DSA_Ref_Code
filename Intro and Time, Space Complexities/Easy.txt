Q - Count Factors

Problem Description

Given an integer A, you need to find the count of it's factors.

Factor of a number is the number which divides it perfectly leaving no remainder.

Example : 1, 2, 3, 6 are factors of 6


Problem Constraints

1 <= A <= 109


Input Format

First and only argument is an integer A.


Output Format

Return the count of factors of A.

Example Input

Input 1:
5
Input 2:
10


Example Output

Output 1:
2
Output 2:
4


Example Explanation

Explanation 1:
Factors of 5 are 1 and 5.
Explanation 2:
Factors of 10 are 1, 2, 5 and 10.

Approach - Factors occurs in pairs.

Code - 

public int solve(int A) {

           // factors occurs in pairs

           int cnt=0;

           int a=1;
            int b=A;

           while( a<b){

               if(A%a == 0){
                
                b = A/a;

                if( a == b){
                    cnt++;
                }else{
                    cnt = cnt+2;
                }
               }
               a++;
           }
           return cnt; 

    }


Q - IsPrime

Problem Description

Given a number A. Return 1 if A is prime and return 0 if not. 

Note : 
The value of A can cross the range of Integer.


Problem Constraints

1 <= A <= 109


Input Format

The first argument is a single integer A.


Output Format

Return 1 if A is prime else return 0.


Example Input

Input 1:
A = 5
Input 2:

A = 10


Example Output

Output 1:
1
Output 2:

0


Example Explanation

Explanation 1:
5 is a prime number.
Explanation 2:

10 is not a prime number.

Approach - cnt no of factors a number has and prime number has 
factors exactly equal to 2.

Code - 

 public int solve(int A) {

        int cnt=0, a=1, b=A;

        while( a<b){

            if( A%a ==0){

                b = A/a;

                if( a == b){
                    cnt++;
                }else{
                    cnt = cnt + 2;
                }
            }

            a++;
        }

  
        if( cnt ==2){
            return 1;
        }else{
            return 0;
        }

    }


Approach 2 - iterate from 2 to sqrt(A) and there is a number
which divides A completely then A is not a prime number.

Code - 

 public int solve(int A) {

        if(A <=1){
            return 0;
        }

        for( int i =2; i * i <= A; i++){

            if( A%i == 0){
                return 0;
            }
        }

        return 1;

    }

Q - 

Find the number of times below code runs where N is a perfect square

for i -> 1 to N

if(i * i == N)

return i

Ans = sqrt(n)


Q -  Find Perfect Numbers

Problem Description

You are given an integer A. You have to tell whether it is a perfect number or not.

Perfect number is a positive integer which is equal to the sum of its proper positive divisors.

A proper divisor of a natural number is the divisor that is strictly less than the number.








Problem Constraints

1 <= A <= 106



Input Format

First and only argument contains a single positive integer A.



Output Format

Return 1 if A is a perfect number and 0 otherwise.



Example Input

Input 1:

A = 4
Input 2:

A = 6


Example Output

Output 1:

0 
Output 2:

1 


Example Explanation

Explanation 1:

For A = 4, the sum of its proper divisors = 1 + 2 = 3, is not equal to 4.
Explanation 2:

For A = 6, the sum of its proper divisors = 1 + 2 + 3 = 6, is equal to 6. 


Approach - 

find out factors sum and compare it with A.

Code -

 public int solve(int A) {


        if( A == 1){
            return 0;
        }

        int sum=1;

        for(int i=2; i*i <=A; i++){

            if( i < A && A%i ==0){
                int b = A/i;

                if( i== b){

                sum = sum + i;
                }else{
                    sum += i + b;
                }
            }
        }


        if( sum == A){
            return 1;
        }else{
            return 0;
        }
    }


Q - Count of primes


Problem Description

You will be given an integer n. You need to return the count of prime numbers less than or equal to n.


Problem Constraints

0 <= n <= 10^3


Input Format

Single input parameter n in function.


Output Format

Return the count of prime numbers less than or equal to n.


Example Input

Input 1:
19
Input 2:
1


Example Output

Output 1:
8
Output 2:
0


Example Explanation

Explanation 1:
Primes <= 19 are 2, 3, 5, 7, 11, 13, 17, 19
Explanation 2:
There are no primes <= 1

Approach - 

iterate from 2 to A and find out if the no is prime or not
and count it.

Code - 

  public int solve(int A) {

        int cnt=0;

        for( int i=2; i<=A; i++){
            if( isPrime(i)){
                cnt++;
            }
        }

        return cnt;
    }

    public static boolean isPrime(int A){

        for(int i =2; i*i <=A; i++){
            if( A%i == 0){
                return false;
            }

            
        }
        return true;
    }


Q - Good Pair

Problem Description

Given an array A and an integer B. A pair(i, j) in the array is a good pair if i != j and (A[i] + A[j] == B). Check if any good pair exist or not.



Problem Constraints

1 <= A.size() <= 104

1 <= A[i] <= 109

1 <= B <= 109



Input Format

First argument is an integer array A.

Second argument is an integer B.



Output Format

Return 1 if good pair exist otherwise return 0.



Example Input

Input 1:

A = [1,2,3,4]
B = 7
Input 2:

A = [1,2,4]
B = 4
Input 3:

A = [1,2,2]
B = 4


Example Output

Output 1:

1
Output 2:

0
Output 3:

1


Example Explanation

Explanation 1:

 (i,j) = (3,4)
Explanation 2:

No pair has sum equal to 4.
Explanation 3:

 (i,j) = (2,3)


 Approach - 

 BF - iterate array twice and find out the pair.

 Code - 

   public int solve(int[] A, int B) {

        for( int i=0; i<A.length; i++){
            
            for( int j=0; j<A.length; j++){

                if( i==j)
                continue;

                if( A[i]+A[j] == B)
                return  1;
            }
        }

        return 0;
    }


Optimised - 

Use hashmap to store the 

solve this question