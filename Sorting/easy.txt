Q - Elements Removal

Problem Description

Given an integer array A of size N. You can remove any element from the array in one operation.
The cost of this operation is the sum of all elements in the array present before this operation.

Find the minimum cost to remove all elements from the array.



Problem Constraints

0 <= N <= 1000
1 <= A[i] <= 103



Input Format

First and only argument is an integer array A.



Output Format

Return an integer denoting the total cost of removing all elements from the array.



Example Input

Input 1:

 A = [2, 1]
Input 2:

 A = [5]


Example Output

Output 1:

 4
Output 2:

 5


Example Explanation

Explanation 1:

 Given array A = [2, 1]
 Remove 2 from the array => [1]. Cost of this operation is (2 + 1) = 3.
 Remove 1 from the array => []. Cost of this operation is (1) = 1.
 So, total cost is = 3 + 1 = 4.
Explanation 2:

 There is only one element in the array. So, cost of removing is 5.

Approach - 
Let’s find the count of how many times an element will contribute to the answer.

Remove any element from the array. The cost of this operation is equal to the sum of array elements irrespective of which element gets removed.

If we remove another element from the array, the cost of this operation will be ( cost of the previous operation - the element which gets removed in the last operation.)

So, we can easily observe that it is wise to remove the highest element first to make the total cost minimum, and elements also follow a pattern.

Element removed first will be added 1 time to the answer.
Element removed second will be added 2 times to the answer.
Element removed third will be added 3 times to the answer.
.
.
.
So on.

We can easily find the total cost in one single loop.

Time Complexity: O(N)
Space Complexity: O(1)


Code - 

   public int solve(int[] A) {

        Arrays.sort(A);

        int n=A.length;
        int multi=1;
        int cost=0;

        for( int i=n-1; i>=0; i--){

            cost += A[i] * multi;
            multi++;

        }

        return cost;
    }



Q - Noble integer 

Problem Description

Given an integer array A, find if an integer p exists in the array such that the number of integers greater than p in the array equals p.



Problem Constraints

1 <= |A| <= 2*105
-108 <= A[i] <= 108


Input Format

First and only argument is an integer array A.



Output Format

Return 1 if any such integer p is present else, return -1.



Example Input

Input 1:

 A = [3, 2, 1, 3]
Input 2:

 A = [1, 1, 3, 3]


Example Output

Output 1:

 1
Output 2:

 -1


Example Explanation

Explanation 1:

 For integer 2, there are 2 greater elements in the array..
Explanation 2:

 There exist no integer satisfying the required conditions.



Approach - 

First, we sort the input array.

Now, all we have to do is to traverse through each element of the array and check whether it matches our given statement. 
Since the array is sorted, we directly know how many elements are greater than that number in the array.

**Note: Please take care of cases when a certain element repeats many times.**

Code - 
    public int solve(int[] A) {

        Arrays.sort(A);
    int n = A.length;

    for (int i = 0; i < n; ) {
        int current = A[i];
        
        // Skip duplicates, count frequency of A[i]
        int j = i;
        while (j < n && A[j] == current) {
            j++;
        }

        int countGreater = n - j;

        if (countGreater == current) {
            return 1;
        }

        i = j; // move to next distinct element
    }

    return -1;

    }

Q - Kth Smallest Element

Problem Description

Find the Bth smallest element in given array A .

NOTE: Users should try to solve it in less than equal to B swaps.



Problem Constraints

1 <= |A| <= 100000

1 <= B <= min(|A|, 500)

1 <= A[i] <= 109



Input Format

The first argument is an integer array A.

The second argument is integer B.



Output Format

Return the Bth smallest element in given array.



Example Input

Input 1:

A = [2, 1, 4, 3, 2]
B = 3
Input 2:

A = [1, 2]
B = 2


Example Output

Output 1:

 2
Output 2:

 2


Example Explanation

Explanation 1:

3rd element after sorting is 2.

Explanation 2:

2nd element after sorting is 2.

Appraoch - 
The algorithm of selection sort should be used.
The selection sort algorithm sorts an array by repeatedly
finding the minimum element (considering ascending order)
from unsorted part and putting it at the beginning.
You need to get the minimum element to the beginning of the array
only B times as you require the Bth element.

Code - 

 public int kthsmallest(final int[] A, int B) {

         int n = A.length;

        for (int i = 0; i < B; i++) {
            int minIndex = i;

            // Find the minimum in the unsorted part
            for (int j = i + 1; j < n; j++) {
                if (A[j] < A[minIndex]) {
                    minIndex = j;
                }
            }

            // Swap it into position i
            int temp = A[i];
            A[i] = A[minIndex];
            A[minIndex] = temp;
        }

        return A[B - 1]; // Bth smallest element   
}


Q -  Largest Number

Given an array A of non-negative integers,
 arrange them such that they form the largest number.

Note: The result may be very large, 
so you need to return a string instead of an integer.

Problem Constraints

1 <= len(A) <= 100000
0 <= A[i] <= 2*109

Example Input

Input 1:

 A = [3, 30, 34, 5, 9]
Input 2:

 A = [2, 3, 9, 0]


Example Output

Output 1:

 "9534330"

Output 2:

 "9320"


Approach - 

Sorting all numbers in descending order is the simplest solution that occurs to us.
But this doesn’t work. 

For example, 548 is greater than 60, but in the output,
 60 comes before 548.
As a second example, 98 is greater than 9,
 but 9 comes before 98 in the output.

The solution is to use any comparison-based sorting algorithm.
 Thus, instead of using the default comparison, 
 write a comparison function myCompare() and use it to sort numbers. 

Given two numbers, X and Y, how should myCompare()
 decide which number to put first – we compare two numbers XY
  (Y appended at the end of X) and YX (X appended at the end of Y). 

If XY is greater, then, in the output, 
X should come before Y, else Y should come before X. 

For example, let X and Y be 542 and 60.
 To compare X and Y, we compare 54260 and 60542. 
 Since 60542 is greater than 54260, we put Y first.

Code - 

public class Solution {
    public String largestNumber(int[] A) {
        
        Integer[] updated = new Integer[A.length];

        for( int i=0; i<A.length; i++){
            updated[i] = A[i];

        }


        Arrays.sort(updated, new largestComparator());

        if(updated[0] == 0){
            return new String("0");
        }

        StringBuilder ans = new StringBuilder();

        for(int a: updated){
            ans.append(a);
        }

        return ans.toString();
    }
}

class largestComparator implements Comparator<Integer> {

    @Override
    public int compare(Integer a, Integer b){
        String order1 = a.toString() + b.toString();
        String order2 = b.toString() + a.toString();

        return order2.compareTo(order1);
    }
}


Q - Factors sort

You are given an array A of N elements. 
Sort the given array in increasing order of number of distinct factors
 of each element, i.e., element having the least number of
  factors should be the first to be displayed and the number 
  having highest number of factors should be the last one. 
  If 2 elements have same number of factors, then number with less 
  value should come first.

Note: You cannot use any extra space

Problem Constraints

1 <= N <= 104
1 <= A[i] <= 104

Example Input

Input 1:
A = [6, 8, 9]
Input 2:
A = [2, 4, 7]


Example Output

Output 1:
[9, 6, 8]
Output 2:
[2, 7, 4]


Appraoch - 

BF - 

Count factors for each element.
Create a new array with [element, factor count] pairs.
Sort this new array based on factor count (and value if counts are equal).
Extract the sorted elements.


Optimization - using custom comparator 

Code - 

public class Solution {
    public int[] solve(int[] A) {
        
        Integer[] updated = new Integer[A.length];

        for(int i=0; i<A.length; i++){
            updated[i] = A[i];
        }
        Arrays.sort(updated, new FactorsComparator());
     

             for(int i=0; i<A.length; i++){
            A[i] = (int) updated[i];
        }


        return A;
    }
}


class FactorsComparator implements Comparator<Integer>{


    public int cntFactors(int n){

        int cnt=0;
        

        for(int i=1; i*i<=n; i++){

            if(n%i == 0){

               int b = n/i;

                if( i == b){
                    cnt++;
                }else{
                    cnt = cnt +2;
                }
            }
        }

        return cnt;
    }

    @Override
    public int compare(Integer a, Integer b){

        int factorsA = cntFactors(a);
        int factorsB = cntFactors(b);

        if(factorsA < factorsB){
            return -1;
        }else if( factorsA > factorsB){
            return 1;
        }else{

           if( a<b) return -1;
           else if(a>b) return 1;
           else return 0;
        }
    }
}


Q - Quick Sort

Given an integer array A, sort the array using Quick Sort.

Problem Constraints

1 <= |A| <= 10^5
1 <= A[i] <= 10^9

Example Input

Input 1:-
A = [1, 4, 10, 2, 1, 5]
Input 2:-
A = [3, 7, 1]


Example Output

Output 1:-
[1, 1, 2, 4, 5, 10]
Output 2:-
[1, 3, 7]

Code - 

 public int[] solve(int[] A) {

        quickSort(A, 0, A.length-1);

        return A;

    }

    public void quickSort(int[] A, int l, int r){

        if( l < r){
            int pi = quickSelect(A, l, r);
            quickSort(A, l, pi-1);
            quickSort(A, pi+1, r);
        }
    }

    public int quickSelect(int[] A, int l, int r){

        int pi = A[l];
        int left=l+1;
        int right = r;


        while( left <= right){

            if(A[left] < pi) left++;
            else if( A[right] > pi) right--;
            else{
                swap(A, left, right);
                left++;
                right--;
            }


        }

            swap(A, l, right);
            return right;
    }

    public void swap(int[] A, int left, int right){
        int temp = A[left];
        A[left]= A[right];
        A[right] = temp;
    }

    
Q - Wave Array

Given an array of integers A, sort the array into a wave-like array and return it.
In other words, arrange the elements into a sequence such that

a1 >= a2 <= a3 >= a4 <= a5..... 
NOTE: If multiple answers are possible, return the lexicographically smallest one.



Problem Constraints

1 <= len(A) <= 106
0 <= A[i] <= 106

Example Input

Input 1:

A = [1, 2, 3, 4]
Input 2:

A = [1, 2]


Example Output

Output 1:

[2, 1, 4, 3]
Output 2:

[2, 1]


Appraoch - Sort the array and then swap the two nearby elements.

Code - 

  public int[] wave(int[] A) {

        // sort the array and swap the elements 

        Arrays.sort(A);

        for(int i=0; i<A.length; i+=2){

            if(i+1 < A.length){
                swap(A, i, i+1);
            }
        }

        return A;

    }

    public static void swap(int[] A, int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }


    Q - B Closest Points to Origin

    You are developing a feature for Zomato that helps users find the nearest restaurants to their current location. It uses GPS to determine the user's location and has access to a database of restaurants, each with its own set of coordinates in a two-dimensional space representing their geographical location on a map. The goal is to identify the "B" closest restaurants to the user, providing a quick and convenient way to choose where to eat.

Given a list of restaurant locations, denoted by A (each represented by its x and y coordinates on a map), and an integer B representing the number of closest restaurants to the user. The user's current location is assumed to be at the origin (0, 0).

Here, the distance between two points on a plane is the Euclidean distance.

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)

NOTE: Euclidean distance between two points P1(x1, y1) and P2(x2, y2) is sqrt( (x1-x2)2 + (y1-y2)2).


Problem Constraints

1 <= B <= length of the list A <= 105
-105 <= A[i][0] <= 105
-105 <= A[i][1] <= 105

Example Input

Input 1:

 A = [ 
       [1, 3],
       [-2, 2] 
     ]
 B = 1
Input 2:

 A = [
       [1, -1],
       [2, -1],
       [3, 3],
       [-2, 4]
    ] 
 B = 3


Example Output

Output 1:

 [ [-2, 2] ]
Output 2:

 [ [1, -1], [2, -1], [3, 3] ]

 Approach - 

 Sort the array based on Euclidean distance from the origin and then 
 return first B elements from the sorted array.

 As we do not require exact Euclidean distance below formula will do the trick - 

 dist = (x2-x1) * ( x2-x1) + (y2-y1) * (y2-y1)

 we want to calculate the distance from origin (0, 0) we can eliminate the x1 and y1 from the above formula.

 dist = x*x + y*y;

 Code - 

  public int[][] solve(int[][] A, int B) {

        // sort based on euclcidien distance and return first B elements from sorted
        // as i will be comparing the distance then do not have to calculate the exact squared root distance
        // dist = (x2-x1) * ( x2-x1) + (y2-y1) * (y2-y1) this formula will work as we just want to compare the distance.

        Point[] updated = new Point[A.length];

        for( int i=0; i < A.length; i++){
            Point p = new Point();
            p.x= A[i][0];
            p.y= A[i][1];
            p.distance = euclideanDistance(A[i][0], A[i][1]);
            updated[i] = p;
        }

        Arrays.sort(updated, new distanceComparator());

        int[][] ans = new int[B][2];

        for( int i =0; i< B; i++){
            ans[i][0] = updated[i].x;
            ans[i][1] = updated[i].y;
        }

        return ans;
    }

        public static double euclideanDistance(int x, int y){
        return x*x + y*y;
    }

}

class distanceComparator implements Comparator<Point>{



    @Override
    public int compare(Point a, Point b){

      

        if(a.distance < b.distance){
            return -1;
        }else if(a.distance > b.distance){
            return 1;
        }else{
            return 0;
        }

    }
}

class Point {
    public double distance;
    public int x;
    public int y;
}


Q -  Sort 01

Given an array A of 0s and 1s of length N. Sort this array.

Note - Do not use any sorting algorithm or library's sort method.



Problem Constraints

1 ≤ N ≤ 105

0 ≤ A[i] ≤ 1

Example Input

Input 1:

A = [0,0,1,0,1,1,0]
Input 2:

A = [1,0]


Example Output

Output 1:

[0,0,0,0,1,1,1]
Output 2:

[0,1]

Approach - as there are only two elements use Count sort.

Code - 

public class Solution {
    public int[] sort01(int[] A) {

        int[] cnt = new int[2];

        for(int i=0; i<A.length; i++){
            cnt[A[i]]++;
        }

        int k=0;
        
        for(int i =0; i < 2; i++){

            for( int j=0; j<cnt[i]; j++){
                A[k++] = i;
            }
        }

        return A;

    }
}





