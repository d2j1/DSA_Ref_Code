Q.1 -  Inversion count in an array

Problem Description

Given an array of integers A. If i < j and A[i] > A[j], 
then the pair (i, j) is called an inversion of A.
Find the total number of inversions of A modulo (10^9 + 7).

Problem Constraints

1 <= length of the array <= 10^5
1 <= A[i] <= 10^9

Example Input

Input 1:

A = [1, 3, 2]

Input 2:

A = [3, 4, 1, 2]


Example Output

Output 1:
1

Output 2:
4


BF - 

iterate with two loops internal loop will run from i to n and
calculate the occurances where A[i] > A[j].

Optimization idea - 

In sorting while merging we can count the pairs where A[i] > A[j], where A[i]
is in first halve and A[j] is in second halve.

example  -

Left = [3, 8], Right = [2, 5]

During merging:

Compare 3 and 2 → 3 > 2 → inversion.
But not just (3,2) — also (8,2) because 8 is also in left and > 2.
So in one step, we counted all remaining left elements as inversions with 2.

This avoids checking each pair individually.

Every time left[i] > right[j], 
all elements from left[i] to end form inversions with right[j].



Code - 

 public int solve(int[] A) {

          int  mod = 1000000007;

        return mergeSort(A, 0, A.length-1, mod);
    }

    public int mergeSort(int[] A, int start, int end, int mod){

        if(start >= end){
            return 0;
        }

        int mid = (start + end ) /2;
        int n1 = mergeSort(A, start, mid, mod);
        int n2 = mergeSort(A, mid+1, end, mod);

        return ( (n1+n2 ) % mod + merge(A, start, mid, end) ) % mod;
    }

    public int merge(int[] A, int start, int mid, int end){

        int n1=mid-start+1;
        int n2=end-mid;

        int[] temp = new int[n1+n2];

        int i=start, j=mid+1;
        int k=0;
        int  inv=0, mod = 1000000007;
        while(i<=mid && j<=end){

            if(A[i]<=A[j]){
                temp[k++] = A[i++];
            }else{
                temp[k++] = A[j++];
                inv += mid-i+1;
                inv = inv % mod;
            }
        }

        while( i<= mid){
            temp[k++] = A[i++];
        }

        while( j<=end){
            temp[k++] = A[j++];
        }

        int s=start;
        for(int l=0; l<temp.length; l++){
            A[s++] = temp[l];
        }

        return inv % mod;
    }


Q.2 - Sort by Color

Given an array with N objects colored red, white, or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will represent the colors as,

red -> 0
white -> 1
blue -> 2

Note: Using the library sort function is not allowed.



Problem Constraints

1 <= N <= 1000000
0 <= A[i] <= 2

Example Input

Input 1 :
    A = [0, 1, 2, 0, 1, 2]
Input 2:

    A = [0]


Example Output

Output 1:
    [0, 0, 1, 1, 2, 2]
Output 2:

    [0]


Example Explanation

Explanation 1:
    [0, 0, 1, 1, 2, 2] is the required order.
Explanation 2:
    [0] is the required order


BF - use Bubble sort or selection sort.

Optimization Observation - 
As there only three values 0 ,1 and 2, so we can use count sort.

Optimized code - 

  public int[] sortColors(int[] A) {

    int[] cnt = new int[3];

    for(int i =0; i<A.length; i++){
        cnt[A[i]]++;
    }

    int k=0;

    for( int i=0; i < cnt.length; i++){

        int temp = cnt[i];

        for( int j=0; j< temp; j++){
            A[k++] = i;
        }
    }

    return A;

    }



    