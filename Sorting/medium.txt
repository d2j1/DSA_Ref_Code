Q.1 -  Inversion count in an array

Problem Description

Given an array of integers A. If i < j and A[i] > A[j], 
then the pair (i, j) is called an inversion of A.
Find the total number of inversions of A modulo (10^9 + 7).

Problem Constraints

1 <= length of the array <= 10^5
1 <= A[i] <= 10^9

Example Input

Input 1:

A = [1, 3, 2]

Input 2:

A = [3, 4, 1, 2]


Example Output

Output 1:
1

Output 2:
4


BF - 

iterate with two loops internal loop will run from i to n and
calculate the occurances where A[i] > A[j].

Optimization idea - 

In sorting while merging we can count the pairs where A[i] > A[j], where A[i]
is in first halve and A[j] is in second halve.

example  -

Left = [3, 8], Right = [2, 5]

During merging:

Compare 3 and 2 → 3 > 2 → inversion.
But not just (3,2) — also (8,2) because 8 is also in left and > 2.
So in one step, we counted all remaining left elements as inversions with 2.

This avoids checking each pair individually.

Every time left[i] > right[j], 
all elements from left[i] to end form inversions with right[j].



Code - 

 public int solve(int[] A) {

          int  mod = 1000000007;

        return mergeSort(A, 0, A.length-1, mod);
    }

    public int mergeSort(int[] A, int start, int end, int mod){

        if(start >= end){
            return 0;
        }

        int mid = (start + end ) /2;
        int n1 = mergeSort(A, start, mid, mod);
        int n2 = mergeSort(A, mid+1, end, mod);

        return ( (n1+n2 ) % mod + merge(A, start, mid, end) ) % mod;
    }

    public int merge(int[] A, int start, int mid, int end){

        int n1=mid-start+1;
        int n2=end-mid;

        int[] temp = new int[n1+n2];

        int i=start, j=mid+1;
        int k=0;
        int  inv=0, mod = 1000000007;
        while(i<=mid && j<=end){

            if(A[i]<=A[j]){
                temp[k++] = A[i++];
            }else{
                temp[k++] = A[j++];
                inv += mid-i+1;
                inv = inv % mod;
            }
        }

        while( i<= mid){
            temp[k++] = A[i++];
        }

        while( j<=end){
            temp[k++] = A[j++];
        }

        int s=start;
        for(int l=0; l<temp.length; l++){
            A[s++] = temp[l];
        }

        return inv % mod;
    }