Q - Max Sum Contiguous Subarray

Problem Description

Given an array A of length N, your task is to find the maximum possible sum of any non-empty contiguous subarray.

In other words, among all possible subarrays of A, determine the one that yields the highest sum and return that sum.



Problem Constraints

1 <= N <= 106
-1000 <= A[i] <= 1000



Input Format

The first and the only argument contains an integer array, A.



Output Format

Return an integer representing the maximum possible sum of the contiguous subarray.



Example Input

Input 1:

 A = [1, 2, 3, 4, -10] 
Input 2:

 A = [-2, 1, -3, 4, -1, 2, 1, -5, 4] 


Example Output

Output 1:

 10 
Output 2:

 6 


Example Explanation

Explanation 1:

 The subarray [1, 2, 3, 4] has the maximum possible sum of 10. 
Explanation 2:

 The subarray [4,-1,2,1] has the maximum possible sum of 6. 

 Approach - 

 This code uses Kadane’s Algorithm to find the maximum sum of a contiguous subarray in linear time.

Here’s how it works in short:

It iterates through the array while keeping track of the current subarray sum (currentSum) and the maximum sum found so far (maxSum).

For each element, it decides whether to start a new subarray at that element (A[i]) or extend the previous subarray (currentSum + A[i]), whichever gives a larger sum.

It updates maxSum whenever a larger subarray sum is found.

Essentially, it dynamically chooses the best possible contiguous subarray ending at each index.

Code - 

   public int maxSubArray(final int[] A) {

         int maxSum = A[0];
        int currentSum = A[0];
        
        for (int i = 1; i < A.length; i++) {
            currentSum = Math.max(A[i], currentSum + A[i]);
            
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;

    }

    Q - Continuous Sum Query

    Problem Description

There are A beggars sitting in a row outside a temple. Each beggar initially has an empty pot. When the devotees come to the temple, they donate some amount of coins to these beggars. Each devotee gives a fixed amount of coin(according to their faith and ability) to some K beggars sitting next to each other.

Given the amount P donated by each devotee to the beggars ranging from L to R index, where 1 <= L <= R <= A, find out the final amount of money in each beggar's pot at the end of the day, provided they don't fill their pots by any other means.
For ith devotee B[i][0] = L, B[i][1] = R, B[i][2] = P, given by the 2D array B


Problem Constraints

1 <= A <= 2 * 105
1 <= L <= R <= A
1 <= P <= 103
0 <= len(B) <= 105


Input Format

The first argument is a single integer A.
The second argument is a 2D integer array B.


Output Format

Return an array(0 based indexing) that stores the total number of coins in each beggars pot.


Example Input

Input 1:-
A = 5
B = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]


Example Output

Output 1:-
10 55 45 25 25


Example Explanation

Explanation 1:-
First devotee donated 10 coins to beggars ranging from 1 to 2. Final amount in each beggars pot after first devotee: [10, 10, 0, 0, 0]
Second devotee donated 20 coins to beggars ranging from 2 to 3. Final amount in each beggars pot after second devotee: [10, 30, 20, 0, 0]
Third devotee donated 25 coins to beggars ranging from 2 to 5. Final amount in each beggars pot after third devotee: [10, 55, 45, 25, 25]

Approach - 

Instead of updating each beggar ranging from i to j, we could update index i with +S and index j + 1 with -S, where S is a donation made by some devotee. So if you want to know the number of coins taken by kth beggar, you just need to find the prefix sum of all the values(coins) from 1 to k(Try to prove it by yourself that values between i to j contains +S as you are doing prefix sum).
This technique is known as difference array and is very helpful in problems which involves range updates.

Time complexity : O(A+n) , where n denotes the size of B

Space complexity : O(A)

Example:
N = 5, D = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]
Initial array: [0, 0, 0, 0, 0]

After first devotee, if we update i = 1 with +10 and j + 1 = 3 with -10, we get [10, 0, -10, 0, 0]. Now note that if you add 10 to 1st index and subtract 10 with 3rd index and do a prefix sum at every array element, you will get +10 at 1st and 2nd.
After second devotee, if we update i = 2 with +20 and j + 1 = 4 with -20, we get [10, 20, -10, -20, 0].
Similarly, after third devotee, if we update i = 2 with +25 and j + 1 = 6 with -25, we get [10, 45, -10, -20, 0].
Now, if we calculate the prefix sum at every index, we get [10, 55, 45, 25, 25].


Code - 


   public int[] solve(int A, int[][] B) {
        
         int[] ans = new int[A];

        if( B.length <= 0){
            return ans;
        }

        for( int i =0; i< B.length; i++){

            int l = B[i][0]-1;
            int r = B[i][1]-1;
            int p = B[i][2];

            ans[l] += p;
            
            if(r < A - 1){
                ans[r+1] -= p; 
            }

        }

        for( int i=1; i< A; i++){
            ans[i] += ans[i-1];
        }

    return ans;
    }

Q - Spiral Order Matrix II

Problem Description

Given an integer A, generate a square matrix filled with elements from 1 to A2 in spiral order and return the generated square matrix.



Problem Constraints

1 <= A <= 1000



Input Format

First and only argument is integer A


Output Format

Return a 2-D matrix which consists of the elements added in spiral order.



Example Input

Input 1:

1
Input 2:

2
Input 3:

5


Example Output

Output 1:

[ [1] ]
Output 2:

[ [1, 2], 
  [4, 3] ]
Output 3:

[ [1,   2,  3,  4, 5], 
  [16, 17, 18, 19, 6], 
  [15, 24, 25, 20, 7], 
  [14, 23, 22, 21, 8], 
  [13, 12, 11, 10, 9] ]


Example Explanation

Explanation 1:

Only 1 is to be arranged.
Explanation 2:

1 --> 2
      |
      |
4<--- 3

Approach - 

Take a matrix of dimensions A*A and initialise r = 0, col = 0 and count = 1

Start iterating on the outermost frame. To iterate it,
iterate from left to right A-1 times, then
iterate from top to bottom A-1 times, then
iterate from right to left A-1 times, then
iterate from bottom to top A-1 times. And keep storing the values accordingly.

Now, in order to move to next inner frame, A will be decremented by 2, r and c will be incremented by 1.

In this way, keep iterating on all the frames.

Time Complexity : O(A^2)

Code - 

 public int[][] generateMatrix(int A) {

         int[][] result = new int[A][A];

        int top = 0, bottom = A - 1;
        int left = 0, right = A - 1;
        int num = 1;

        while (top <= bottom && left <= right) {
            // left to right
            for (int i = left; i <= right; i++) {
                result[top][i] = num++;
            }
            top++;

            // top to bottom
            for (int i = top; i <= bottom; i++) {
                result[i][right] = num++;
            }
            right--;

            // right to left
            if (top <= bottom) {
                for (int i = right; i >= left; i--) {
                    result[bottom][i] = num++;
                }
                bottom--;
            }

            // bottom to top
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result[i][left] = num++;
                }
                left++;
            }
        }

        return result;
    }

