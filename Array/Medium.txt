
Q - Rain Water Trapped


Problem Description

Imagine a histogram where the bars' heights are given by the array A. Each bar is of uniform width, which is 1 unit. When it rains, water will accumulate in the valleys between the bars.

Your task is to calculate the total amount of water that can be trapped in these valleys.

Example:

The Array A = [5, 4, 1, 4, 3, 2, 7] is visualized as below. The total amount of rain water trapped in A is 11.


Rain Water Trapped




Problem Constraints

1 <= |A| <= 105
0 <= A[i] <= 105



Input Format

First and only argument is the Integer Array, A.



Output Format

Return an Integer, denoting the total amount of water that can be trapped in these valleys



Example Input

Input 1:

 A = [0, 1, 0, 2]
Input 2:

A = [1, 2]


Example Output

Output 1:

1
Output 2:

0


Example Explanation

Explanation 1:

1 unit is trapped on top of the 3rd element.
Rain Water Histogram
Explanation 2:

No water is trapped.

Appraoch - 

Instead of calculating area by height*width, we can think it in a cumulative way.
In other words, we can sum the water amount of each bin(width=1).

Approach 1

We can keep 2 arrays ‘pre’ and ‘suf’. pre[i] is the maximum height for all i from 0 to i and suf[i] is the maximum height for all i from i to n-1.
Now for each i from 1 to n-2 (as no water can be stored at indexes 0 and 1) just add the maximum amount water that can be stored. The maximum amount of water that can be stored is the minimum of(max height towards left of i,max height towards right of i)-A[i]
i.e. min(pre[i-1],suf[i+1])-A[i]. But if min(pre[i-1],suf[i+1])-A[i]<0 we dont add anything. (i.e we add 0)

Time Complexity : O(n)
Auxiliary Spcae : O(n)

Code - 

 public int trap(final int[] A) {

        int n = A.length;

        if(n == 0 ){
            return 0;
        }

        int[] pfm = new int[n];
        int[] sfm = new int[n];

        // calculate prefix max 
        pfm[0] = A[0];

        for( int i=1; i<n; i++){
            pfm[i] = Math.max(pfm[i-1], A[i]);
        }

        // calculate suffix max 

        sfm[n-1] = A[n-1];

        for( int i =n-2; i >=0 ; i--){
            sfm[i] = Math.max(sfm[i+1], A[i]);
        }

        int water =0;

        for(int i =0 ; i<n; i++){
            water += Math.min(sfm[i], pfm[i]) - A[i];
        }

        return water;

    }


    Approach 2 - 

    Approach 2 (Most Efficient)

We can use the concept of two pointers.
Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of a partial container. Fix the higher one and flow water
from the lower part. For example, if the current height of the left is lower, we fill water in the left bin. Until the left meets right,
we filled the whole container.

We will follow the below steps:

1) Maintain two variables ‘left’ and ‘right’ (‘left’ denotes the left pointer and ‘right’ denotes the right pointer) and initialize it to 0 and n-1 respectively.
2) Also maintain two variables ‘leftmax’ and ‘rightmax’ (‘leftmax’ denotes the maximum height till ‘left’ ( i.e. from 0 to left) and ‘rightmax’ denotes the maximum height till ‘right’(i.e. from right to n-1) ) and initialize both of them to 0.
3) while left <= right we have two possible conditions

Condition 1: leftmax<=rightmax
For the element at index left , we have already traversed from 0 to left , therefore leftmax is known. But rightmax of left'th index is not known. We only know the rightmax for right.
But we know that rightmax can only get bigger from right to left,and we already know that leftmax<=rightmax,  therefore leftmax of left <= rightmax of left. 
Now we can simply add leftmax-A[left] , if this quantity is positive
otherwise change leftmax to A[left].
Increment left.

Condition 2: leftmax>rightmax
For the element at index right , we have already traversed from n-1 to right , therefore rightmax is known. But leftmax of right'th index is not known. We only know the leftmax for left.
But we know that leftmax can only get bigger from left to right, and we already know that leftmax>rightmax,  therefore rightmax of right < leftmax of right. 
Now we can simply add rightmax-A[right] , if this quantity is positive
otherwise change rightmax to A[right].
decrement right
Time Complexity : O(n)
Auxiliary Spcae : O(1)


Code - 

 public int trap(final int[] A) {
        int n = A.length;
        int left = 0; 
        int right = n - 1;
        int res = 0;
        int maxleft = 0, maxright = 0;
        while(left <= right){ 
            // When height of left side is lower, calculate height of water trapped in left bin else calculate for right bin
            if(A[left] <= A[right]){
                if(A[left] >= maxleft) 
                    maxleft = A[left]; //This index wont store any water as there is no index towards the left whose height is greater than this.
                else 
                    res += maxleft - A[left];
                left++;
            }
            else{
                if(A[right] >= maxright) 
                    maxright = A[right]; //This index wont store any water as there is no index towards the right whose height is greater than this.
                else 
                    res += maxright - A[right];
                right--;
            }
        }
        return res;
    }

Q - Add One To Number

Problem Description

Given a non-negative number represented as an array of digits, add 1 to the number ( increment the number represented by the digits ).






The digits are stored such that the most significant digit is at the head of the list.

NOTE: Certain things are intentionally left unclear in this question which you should practice asking the interviewer. For example: for this problem, the following are some good questions to ask :

Q: Can the input have 0's before the most significant digit. Or, in other words, is 0 1 2 3 a valid input?
A: For the purpose of this question, YES
Q: Can the output have 0's before the most significant digit? Or, in other words, is 0 1 2 4 a valid output?
A: For the purpose of this question, NO. Even if the input has zeroes before the most significant digit.







Problem Constraints

1 <= size of the array <= 1000000



Input Format

First argument is an array of digits.



Output Format

Return the array of digits after adding one.



Example Input

Input 1:

[1, 2, 3]


Example Output

Output 1:

[1, 2, 4]


Example Explanation

Explanation 1:

Given vector is [1, 2, 3].
The returned vector should be [1, 2, 4] as 123 + 1 = 124.


Appraoch 1 - 

 public int[] plusOne(int[] A) {

        int n = A.length;
        int start = 0;
        
        // Step 1: Remove leading zeros
        while (start < n && A[start] == 0) {
            start++;
        }
        
        // If array has only zeros
        if (start == n) {
            return new int[]{1};
        }
        
        // Create a new array without leading zeros
        int[] temp = Arrays.copyOfRange(A, start, n);
        
        int carry = 1; // We need to add 1
        for (int i = temp.length - 1; i >= 0; i--) {
            int sum = temp[i] + carry;
            temp[i] = sum % 10;
            carry = sum / 10;
        }
        
        // Step 3: If carry still remains
        if (carry > 0) {
            int[] result = new int[temp.length + 1];
            result[0] = carry;
            for (int i = 0; i < temp.length; i++) {
                result[i + 1] = temp[i];
            }
            return result;
        }
        
        return temp;
    }


Approach 2 - 

public ArrayList<Integer> plusOne(ArrayList<Integer> A) {
	    
	    int carry = 1;
	    int num;
	    int size = A.size();
	    
	    // traversing the digits of the number in reverse order
	    for (int i = size - 1; i >= 0; i--) {
	        
	        num = A.get(i);
	        num += carry;
	        carry = 0;
	        
	        if (num == 10) {
	            num = 0;
	            carry = 1;
	        }
	        
	        A.set(i, num);
	        
	    }
	    
	    ArrayList<Integer> res = new ArrayList<Integer>();
	    
	    if (carry == 1)
	        res.add(1);
	    
	    for (int x : A) {
	        if (x == 0 && res.size() == 0)
	            continue;
	        res.add(x);
	    }
	    
	    return res;
	    
	}

Q - Flip

Problem Description

You are given a binary string A(i.e., with characters 0 and 1) consisting of characters A1, A2, ..., AN. In a single operation, you can choose two indices, L and R, such that 1 ≤ L ≤ R ≤ N and flip the characters AL, AL+1, ..., AR. By flipping, we mean changing character 0 to 1 and vice-versa.





Your aim is to perform ATMOST one operation such that in the final string number of 1s is maximized.

If you don't want to perform the operation, return an empty array. Else, return an array consisting of two elements denoting L and R. If there are multiple solutions, return the lexicographically smallest pair of L and R.

NOTE: Pair (a, b) is lexicographically smaller than pair (c, d) if a < c or, if a == c and b < d.







Problem Constraints

1 <= size of string <= 100000



Input Format

First and only argument is a string A.



Output Format

Return an array of integers denoting the answer.



Example Input

Input 1:

A = "010"
Input 2:

A = "111"


Example Output

Output 1:

[1, 1]
Output 2:

[]


Example Explanation

Explanation 1:

A = "010"

Pair of [L, R] | Final string
_______________|_____________
[1 1]          | "110"
[1 2]          | "100"
[1 3]          | "101"
[2 2]          | "000"
[2 3]          | "001"

We see that two pairs [1, 1] and [1, 3] give same number of 1s in final string. So, we return [1, 1].
Explanation 2:

No operation can give us more than three 1s in final string. So, we return empty array [].


Appraoch - 

Note the net change in the number of 1s in string S when we flip bits of string S.
Say it has A 0s and B 1s. Eventually, there are B 0s and A 1s.

So, the number of 1s increased by A - B. We want to choose a subarray that maximizes this. Note that if we change 1s to -1, the sum of values will give us A - B. Then, we have to find a subarray with the maximum sum, which can be done via Kadane’s Algorithm.

Code - 

 public int[] flip(String A) {
    
      int n = A.length();
        int maxSum = Integer.MIN_VALUE;
        int currentSum = 0;
        
        int start = 0; 
        int bestStart = -1;
        int bestEnd = -1;
        
        for (int i = 0; i < n; i++) {
            int value = (A.charAt(i) == '0') ? 1 : -1;
            currentSum += value;
            
            if (currentSum > maxSum) {
                maxSum = currentSum;
                bestStart = start;
                bestEnd = i;
            }
            
            if (currentSum < 0) {
                currentSum = 0;
                start = i + 1;
            }
        }
        
        if (maxSum <= 0) {
            return new int[0]; // Return empty array
        }
        
        // 0-based to 1-based indexing
        return new int[]{bestStart + 1, bestEnd + 1};
    
    }

Q - Given a matrix of integers A of size N x M and an integer B.

In the given matrix every row and column is sorted in non-decreasing order. Find and return the position of B in the matrix in the given form:
If A[i][j] = B then return (i * 1009 + j)
If B is not present return -1.

Note 1: Rows are numbered from top to bottom and columns are numbered from left to right.
Note 2: If there are multiple B in A then return the smallest value of i*1009 +j such that A[i][j]=B.
Note 3: Expected time complexity is linear
Note 4: Use 1-based indexing


Problem Constraints

1 <= N, M <= 1000
-100000 <= A[i] <= 100000
-100000 <= B <= 100000


Input Format

The first argument given is the integer matrix A.
The second argument given is the integer B.


Output Format

Return the position of B and if it is not present in A return -1 instead.


Example Input

Input 1:-
A = [[1, 2, 3]
     [4, 5, 6]
     [7, 8, 9]]
B = 2
Input 2:-
A = [[1, 2]
     [3, 3]]
B = 3


Example Output

Output 1:-
1011
Output 2:-
2019


Example Explanation

Expanation 1:-
A[1][2] = 2
1 * 1009 + 2 = 1011
Explanation 2:-
A[2][1] = 3
2 * 1009 + 1 = 2019
A[2][2] = 3
2 * 1009 + 2 = 2020
The minimum value is 2019

Appraoch - 

We search traversing from the top right corner of the matrix.
1) Check if the current element is greater than B,
then exclude the current column and move to the left column.
2) Check if the current element is less than B, then exclude the 
current row and move to the bottom row.
3) If the current element if equal to B, then the final answer will
be due to the leftmost occurence of B in the current row.

Time Complexity : O(N + M)
Space Complexity : O(1)

Code - 

 public int solve(int[][] A, int B) {


            int n = A.length;
        int m = A[0].length;
        int i = 0;
        int j = m - 1;
        int minValue = Integer.MAX_VALUE;

        while (i < n && j >= 0) {
            if (A[i][j] == B) {
                int pos = (i + 1) * 1009 + (j + 1);  // 1-based indexing
                minValue = Math.min(minValue, pos);
                j--;
            } else if (A[i][j] > B) {
                j--;
            } else {
                i++;
            }
        }

        return minValue == Integer.MAX_VALUE ? -1 : minValue;


    }


Q -  Sum of all Submatrices

Problem Description

Given a 2D Matrix A of dimensions N*N, we need to return the sum of all possible submatrices.



Problem Constraints

1 <= N <=30

0 <= A[i][j] <= 10



Input Format

Single argument representing a 2-D array A of size N x N.



Output Format

Return an integer denoting the sum of all possible submatrices in the given matrix.



Example Input

Input 1:
A = [ [1, 1]
      [1, 1] ]
Input 2:
A = [ [1, 2]
      [3, 4] ]


Example Output

Output 1:
16
Output 2:
40


Example Explanation

Example 1:
Number of submatrices with 1 elements = 4, so sum of all such submatrices = 4 * 1 = 4
Number of submatrices with 2 elements = 4, so sum of all such submatrices = 4 * 2 = 8
Number of submatrices with 3 elements = 0
Number of submatrices with 4 elements = 1, so sum of such submatrix = 4
Total Sum = 4+8+4 = 16

Example 2:
The submatrices are [1], [2], [3], [4], [1, 2], [3, 4], [1, 3], [2, 4] and [[1, 2], [3, 4]].
Total sum = 40


Approach - 

Let us suppose the index of an element be (X, Y) in 0 based indexing, then the number of submatrices Sub(x,y) for this element
can be given by the formula Sub(x, y) = (X + 1) * (Y + 1) * (N – X) * (N – Y) .
This formula works because we just have to choose two different positions on the matrix that will create a submatrix that
envelopes the element. Thus, for each element, ‘sum’ can be updated as sum += Sub(x,y) * A[x][y].

More Formally,
Number of ways to choose from top-left elements (X + 1) * (Y + 1)
Number of ways to choose from bottom-right elements (N - X) * (N - Y)

Code - 

 public int solve(int[][] A) {

          int N = A.length;
        long totalSum = 0;

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                long topLeftOptions = (i + 1L) * (j + 1L);
                long bottomRightOptions = (N - i) * (N - j);
                long contribution = A[i][j] * topLeftOptions * bottomRightOptions;
                totalSum += contribution;
            }
        }

        return (int) totalSum;
    }

Q - Row with maximum number of ones

Problem Description

Given a binary sorted matrix A of size N x N. Find the row with the maximum number of 1.

NOTE:

If two rows have the maximum number of 1 then return the row which has a lower index.
Rows are numbered from top to bottom and columns are numbered from left to right.
Assume 0-based indexing.
Assume each row to be sorted by values.
Expected time complexity is O(rows + columns).


Problem Constraints

1 <= N <= 1000

0 <= A[i] <= 1



Input Format

The only argument given is the integer matrix A.



Output Format

Return the row with the maximum number of 1.



Example Input

Input 1:

 A = [   [0, 1, 1]
         [0, 0, 1]
         [0, 1, 1]   ]
Input 2:

 A = [   [0, 0, 0, 0]
         [0, 0, 0, 1]
         [0, 0, 1, 1]
         [0, 1, 1, 1]    ]


Example Output

Output 1:

 0
Output 2:

 3


Example Explanation

Explanation 1:

 Row 0 has maximum number of 1s.
Explanation 2:

 Row 3 has maximum number of 1s.


 Appraoch - 

 Given a binary sorted matrix A of size N x N. Find the row with the maximum number of 1.

NOTE:

If two rows have the maximum number of 1 then return the row which has a lower index.
Rows are numbered from top to bottom and columns are numbered from left to right.
Assume 0-based indexing.
Assume each row to be sorted by values.
Expected time complexity is O(rows + columns).


Code - 

 public int solve(int[][] A) {

         int n = A.length;
        int maxRowIndex = -1;
        int j = n - 1; 

        for (int i = 0; i < n; i++) {
         
            while (j >= 0 && A[i][j] == 1) {
                j--;
                maxRowIndex = i; 
            }
        }

        return maxRowIndex;

    }

Q - Minimum Swaps


Problem Description

Given an array of integers A and an integer B, find and return the minimum number of swaps required to bring all the numbers less than or equal to B together.

Note: It is possible to swap any two elements, not necessarily consecutive.



Problem Constraints

1 <= length of the array <= 100000
-109 <= A[i], B <= 109



Input Format

The first argument given is the integer array A.
The second argument given is the integer B.



Output Format

Return the minimum number of swaps.



Example Input

Input 1:

 A = [1, 12, 10, 3, 14, 10, 5]
 B = 8
Input 2:

 A = [5, 17, 100, 11]
 B = 20


Example Output

Output 1:

 2
Output 2:

 1


Example Explanation

Explanation 1:

 A = [1, 12, 10, 3, 14, 10, 5]
 After swapping  12 and 3, A => [1, 3, 10, 12, 14, 10, 5].
 After swapping  the first occurence of 10 and 5, A => [1, 3, 5, 12, 14, 10, 10].
 Now, all elements less than or equal to 8 are together.
Explanation 2:

 A = [5, 17, 100, 11]
 After swapping 100 and 11, A => [5, 17, 11, 100].
 Now, all elements less than or equal to 20 are together.

 Appraoch - 

 First, count the number of elements <= B. Let the count comes out to be X.

Create a window of first X elements. To find the number of swaps to bring all elements <= B together in the first window,
you just need to find count of elements > B in first window.
So, count of swaps required in 1 window = count of elements greater than B in that window.

For every window, find the count of elements greater than B, using sliding window technique.

Time Complexity: O(N)
Space Complexity: O(1)

Code - 

  public int solve(int[] A, int B) {

         int n = A.length;
        
       
        int countGood = 0;
        for (int num : A) {
            if (num <= B) {
                countGood++;
            }
        }

       
        int bad = 0;
        for (int i = 0; i < countGood; i++) {
            if (A[i] > B) {
                bad++;
            }
        }

        int minSwaps = bad;

       
        for (int i = 1, j = countGood; j < n; i++, j++) {
            if (A[i - 1] > B) bad--; 
            if (A[j] > B) bad++;    
            minSwaps = Math.min(minSwaps, bad);
        }

        return minSwaps;
    }
