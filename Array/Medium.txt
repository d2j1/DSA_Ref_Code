
Q - Rain Water Trapped


Problem Description

Imagine a histogram where the bars' heights are given by the array A. Each bar is of uniform width, which is 1 unit. When it rains, water will accumulate in the valleys between the bars.

Your task is to calculate the total amount of water that can be trapped in these valleys.

Example:

The Array A = [5, 4, 1, 4, 3, 2, 7] is visualized as below. The total amount of rain water trapped in A is 11.


Rain Water Trapped




Problem Constraints

1 <= |A| <= 105
0 <= A[i] <= 105



Input Format

First and only argument is the Integer Array, A.



Output Format

Return an Integer, denoting the total amount of water that can be trapped in these valleys



Example Input

Input 1:

 A = [0, 1, 0, 2]
Input 2:

A = [1, 2]


Example Output

Output 1:

1
Output 2:

0


Example Explanation

Explanation 1:

1 unit is trapped on top of the 3rd element.
Rain Water Histogram
Explanation 2:

No water is trapped.

Appraoch - 

Instead of calculating area by height*width, we can think it in a cumulative way.
In other words, we can sum the water amount of each bin(width=1).

Approach 1

We can keep 2 arrays ‘pre’ and ‘suf’. pre[i] is the maximum height for all i from 0 to i and suf[i] is the maximum height for all i from i to n-1.
Now for each i from 1 to n-2 (as no water can be stored at indexes 0 and 1) just add the maximum amount water that can be stored. The maximum amount of water that can be stored is the minimum of(max height towards left of i,max height towards right of i)-A[i]
i.e. min(pre[i-1],suf[i+1])-A[i]. But if min(pre[i-1],suf[i+1])-A[i]<0 we dont add anything. (i.e we add 0)

Time Complexity : O(n)
Auxiliary Spcae : O(n)

Code - 

 public int trap(final int[] A) {

        int n = A.length;

        if(n == 0 ){
            return 0;
        }

        int[] pfm = new int[n];
        int[] sfm = new int[n];

        // calculate prefix max 
        pfm[0] = A[0];

        for( int i=1; i<n; i++){
            pfm[i] = Math.max(pfm[i-1], A[i]);
        }

        // calculate suffix max 

        sfm[n-1] = A[n-1];

        for( int i =n-2; i >=0 ; i--){
            sfm[i] = Math.max(sfm[i+1], A[i]);
        }

        int water =0;

        for(int i =0 ; i<n; i++){
            water += Math.min(sfm[i], pfm[i]) - A[i];
        }

        return water;

    }


    Approach 2 - 

    Approach 2 (Most Efficient)

We can use the concept of two pointers.
Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of a partial container. Fix the higher one and flow water
from the lower part. For example, if the current height of the left is lower, we fill water in the left bin. Until the left meets right,
we filled the whole container.

We will follow the below steps:

1) Maintain two variables ‘left’ and ‘right’ (‘left’ denotes the left pointer and ‘right’ denotes the right pointer) and initialize it to 0 and n-1 respectively.
2) Also maintain two variables ‘leftmax’ and ‘rightmax’ (‘leftmax’ denotes the maximum height till ‘left’ ( i.e. from 0 to left) and ‘rightmax’ denotes the maximum height till ‘right’(i.e. from right to n-1) ) and initialize both of them to 0.
3) while left <= right we have two possible conditions

Condition 1: leftmax<=rightmax
For the element at index left , we have already traversed from 0 to left , therefore leftmax is known. But rightmax of left'th index is not known. We only know the rightmax for right.
But we know that rightmax can only get bigger from right to left,and we already know that leftmax<=rightmax,  therefore leftmax of left <= rightmax of left. 
Now we can simply add leftmax-A[left] , if this quantity is positive
otherwise change leftmax to A[left].
Increment left.

Condition 2: leftmax>rightmax
For the element at index right , we have already traversed from n-1 to right , therefore rightmax is known. But leftmax of right'th index is not known. We only know the leftmax for left.
But we know that leftmax can only get bigger from left to right, and we already know that leftmax>rightmax,  therefore rightmax of right < leftmax of right. 
Now we can simply add rightmax-A[right] , if this quantity is positive
otherwise change rightmax to A[right].
decrement right
Time Complexity : O(n)
Auxiliary Spcae : O(1)


Code - 

 public int trap(final int[] A) {
        int n = A.length;
        int left = 0; 
        int right = n - 1;
        int res = 0;
        int maxleft = 0, maxright = 0;
        while(left <= right){ 
            // When height of left side is lower, calculate height of water trapped in left bin else calculate for right bin
            if(A[left] <= A[right]){
                if(A[left] >= maxleft) 
                    maxleft = A[left]; //This index wont store any water as there is no index towards the left whose height is greater than this.
                else 
                    res += maxleft - A[left];
                left++;
            }
            else{
                if(A[right] >= maxright) 
                    maxright = A[right]; //This index wont store any water as there is no index towards the right whose height is greater than this.
                else 
                    res += maxright - A[right];
                right--;
            }
        }
        return res;
    }

Q - Add One To Number

Problem Description

Given a non-negative number represented as an array of digits, add 1 to the number ( increment the number represented by the digits ).






The digits are stored such that the most significant digit is at the head of the list.

NOTE: Certain things are intentionally left unclear in this question which you should practice asking the interviewer. For example: for this problem, the following are some good questions to ask :

Q: Can the input have 0's before the most significant digit. Or, in other words, is 0 1 2 3 a valid input?
A: For the purpose of this question, YES
Q: Can the output have 0's before the most significant digit? Or, in other words, is 0 1 2 4 a valid output?
A: For the purpose of this question, NO. Even if the input has zeroes before the most significant digit.







Problem Constraints

1 <= size of the array <= 1000000



Input Format

First argument is an array of digits.



Output Format

Return the array of digits after adding one.



Example Input

Input 1:

[1, 2, 3]


Example Output

Output 1:

[1, 2, 4]


Example Explanation

Explanation 1:

Given vector is [1, 2, 3].
The returned vector should be [1, 2, 4] as 123 + 1 = 124.


Appraoch 1 - 

 public int[] plusOne(int[] A) {

        int n = A.length;
        int start = 0;
        
        // Step 1: Remove leading zeros
        while (start < n && A[start] == 0) {
            start++;
        }
        
        // If array has only zeros
        if (start == n) {
            return new int[]{1};
        }
        
        // Create a new array without leading zeros
        int[] temp = Arrays.copyOfRange(A, start, n);
        
        int carry = 1; // We need to add 1
        for (int i = temp.length - 1; i >= 0; i--) {
            int sum = temp[i] + carry;
            temp[i] = sum % 10;
            carry = sum / 10;
        }
        
        // Step 3: If carry still remains
        if (carry > 0) {
            int[] result = new int[temp.length + 1];
            result[0] = carry;
            for (int i = 0; i < temp.length; i++) {
                result[i + 1] = temp[i];
            }
            return result;
        }
        
        return temp;
    }


Approach 2 - 

public ArrayList<Integer> plusOne(ArrayList<Integer> A) {
	    
	    int carry = 1;
	    int num;
	    int size = A.size();
	    
	    // traversing the digits of the number in reverse order
	    for (int i = size - 1; i >= 0; i--) {
	        
	        num = A.get(i);
	        num += carry;
	        carry = 0;
	        
	        if (num == 10) {
	            num = 0;
	            carry = 1;
	        }
	        
	        A.set(i, num);
	        
	    }
	    
	    ArrayList<Integer> res = new ArrayList<Integer>();
	    
	    if (carry == 1)
	        res.add(1);
	    
	    for (int x : A) {
	        if (x == 0 && res.size() == 0)
	            continue;
	        res.add(x);
	    }
	    
	    return res;
	    
	}

Q - Flip

Problem Description

You are given a binary string A(i.e., with characters 0 and 1) consisting of characters A1, A2, ..., AN. In a single operation, you can choose two indices, L and R, such that 1 ≤ L ≤ R ≤ N and flip the characters AL, AL+1, ..., AR. By flipping, we mean changing character 0 to 1 and vice-versa.





Your aim is to perform ATMOST one operation such that in the final string number of 1s is maximized.

If you don't want to perform the operation, return an empty array. Else, return an array consisting of two elements denoting L and R. If there are multiple solutions, return the lexicographically smallest pair of L and R.

NOTE: Pair (a, b) is lexicographically smaller than pair (c, d) if a < c or, if a == c and b < d.







Problem Constraints

1 <= size of string <= 100000



Input Format

First and only argument is a string A.



Output Format

Return an array of integers denoting the answer.



Example Input

Input 1:

A = "010"
Input 2:

A = "111"


Example Output

Output 1:

[1, 1]
Output 2:

[]


Example Explanation

Explanation 1:

A = "010"

Pair of [L, R] | Final string
_______________|_____________
[1 1]          | "110"
[1 2]          | "100"
[1 3]          | "101"
[2 2]          | "000"
[2 3]          | "001"

We see that two pairs [1, 1] and [1, 3] give same number of 1s in final string. So, we return [1, 1].
Explanation 2:

No operation can give us more than three 1s in final string. So, we return empty array [].


Appraoch - 

Note the net change in the number of 1s in string S when we flip bits of string S.
Say it has A 0s and B 1s. Eventually, there are B 0s and A 1s.

So, the number of 1s increased by A - B. We want to choose a subarray that maximizes this. Note that if we change 1s to -1, the sum of values will give us A - B. Then, we have to find a subarray with the maximum sum, which can be done via Kadane’s Algorithm.

Code - 

 public int[] flip(String A) {
    
      int n = A.length();
        int maxSum = Integer.MIN_VALUE;
        int currentSum = 0;
        
        int start = 0; 
        int bestStart = -1;
        int bestEnd = -1;
        
        for (int i = 0; i < n; i++) {
            int value = (A.charAt(i) == '0') ? 1 : -1;
            currentSum += value;
            
            if (currentSum > maxSum) {
                maxSum = currentSum;
                bestStart = start;
                bestEnd = i;
            }
            
            if (currentSum < 0) {
                currentSum = 0;
                start = i + 1;
            }
        }
        
        if (maxSum <= 0) {
            return new int[0]; // Return empty array
        }
        
        // 0-based to 1-based indexing
        return new int[]{bestStart + 1, bestEnd + 1};
    
    }

Q - Given a matrix of integers A of size N x M and an integer B.

In the given matrix every row and column is sorted in non-decreasing order. Find and return the position of B in the matrix in the given form:
If A[i][j] = B then return (i * 1009 + j)
If B is not present return -1.

Note 1: Rows are numbered from top to bottom and columns are numbered from left to right.
Note 2: If there are multiple B in A then return the smallest value of i*1009 +j such that A[i][j]=B.
Note 3: Expected time complexity is linear
Note 4: Use 1-based indexing


Problem Constraints

1 <= N, M <= 1000
-100000 <= A[i] <= 100000
-100000 <= B <= 100000


Input Format

The first argument given is the integer matrix A.
The second argument given is the integer B.


Output Format

Return the position of B and if it is not present in A return -1 instead.


Example Input

Input 1:-
A = [[1, 2, 3]
     [4, 5, 6]
     [7, 8, 9]]
B = 2
Input 2:-
A = [[1, 2]
     [3, 3]]
B = 3


Example Output

Output 1:-
1011
Output 2:-
2019


Example Explanation

Expanation 1:-
A[1][2] = 2
1 * 1009 + 2 = 1011
Explanation 2:-
A[2][1] = 3
2 * 1009 + 1 = 2019
A[2][2] = 3
2 * 1009 + 2 = 2020
The minimum value is 2019

Appraoch - 

We search traversing from the top right corner of the matrix.
1) Check if the current element is greater than B,
then exclude the current column and move to the left column.
2) Check if the current element is less than B, then exclude the 
current row and move to the bottom row.
3) If the current element if equal to B, then the final answer will
be due to the leftmost occurence of B in the current row.

Time Complexity : O(N + M)
Space Complexity : O(1)

Code - 

 public int solve(int[][] A, int B) {


            int n = A.length;
        int m = A[0].length;
        int i = 0;
        int j = m - 1;
        int minValue = Integer.MAX_VALUE;

        while (i < n && j >= 0) {
            if (A[i][j] == B) {
                int pos = (i + 1) * 1009 + (j + 1);  // 1-based indexing
                minValue = Math.min(minValue, pos);
                j--;
            } else if (A[i][j] > B) {
                j--;
            } else {
                i++;
            }
        }

        return minValue == Integer.MAX_VALUE ? -1 : minValue;


    }


Q -  Sum of all Submatrices

Problem Description

Given a 2D Matrix A of dimensions N*N, we need to return the sum of all possible submatrices.



Problem Constraints

1 <= N <=30

0 <= A[i][j] <= 10



Input Format

Single argument representing a 2-D array A of size N x N.



Output Format

Return an integer denoting the sum of all possible submatrices in the given matrix.



Example Input

Input 1:
A = [ [1, 1]
      [1, 1] ]
Input 2:
A = [ [1, 2]
      [3, 4] ]


Example Output

Output 1:
16
Output 2:
40


Example Explanation

Example 1:
Number of submatrices with 1 elements = 4, so sum of all such submatrices = 4 * 1 = 4
Number of submatrices with 2 elements = 4, so sum of all such submatrices = 4 * 2 = 8
Number of submatrices with 3 elements = 0
Number of submatrices with 4 elements = 1, so sum of such submatrix = 4
Total Sum = 4+8+4 = 16

Example 2:
The submatrices are [1], [2], [3], [4], [1, 2], [3, 4], [1, 3], [2, 4] and [[1, 2], [3, 4]].
Total sum = 40


Approach - 

Let us suppose the index of an element be (X, Y) in 0 based indexing, then the number of submatrices Sub(x,y) for this element
can be given by the formula Sub(x, y) = (X + 1) * (Y + 1) * (N – X) * (N – Y) .
This formula works because we just have to choose two different positions on the matrix that will create a submatrix that
envelopes the element. Thus, for each element, ‘sum’ can be updated as sum += Sub(x,y) * A[x][y].

More Formally,
Number of ways to choose from top-left elements (X + 1) * (Y + 1)
Number of ways to choose from bottom-right elements (N - X) * (N - Y)

Code - 

 public int solve(int[][] A) {

          int N = A.length;
        long totalSum = 0;

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                long topLeftOptions = (i + 1L) * (j + 1L);
                long bottomRightOptions = (N - i) * (N - j);
                long contribution = A[i][j] * topLeftOptions * bottomRightOptions;
                totalSum += contribution;
            }
        }

        return (int) totalSum;
    }

Q - Row with maximum number of ones

Problem Description

Given a binary sorted matrix A of size N x N. Find the row with the maximum number of 1.

NOTE:

If two rows have the maximum number of 1 then return the row which has a lower index.
Rows are numbered from top to bottom and columns are numbered from left to right.
Assume 0-based indexing.
Assume each row to be sorted by values.
Expected time complexity is O(rows + columns).


Problem Constraints

1 <= N <= 1000

0 <= A[i] <= 1



Input Format

The only argument given is the integer matrix A.



Output Format

Return the row with the maximum number of 1.



Example Input

Input 1:

 A = [   [0, 1, 1]
         [0, 0, 1]
         [0, 1, 1]   ]
Input 2:

 A = [   [0, 0, 0, 0]
         [0, 0, 0, 1]
         [0, 0, 1, 1]
         [0, 1, 1, 1]    ]


Example Output

Output 1:

 0
Output 2:

 3


Example Explanation

Explanation 1:

 Row 0 has maximum number of 1s.
Explanation 2:

 Row 3 has maximum number of 1s.


 Appraoch - 

 Given a binary sorted matrix A of size N x N. Find the row with the maximum number of 1.

NOTE:

If two rows have the maximum number of 1 then return the row which has a lower index.
Rows are numbered from top to bottom and columns are numbered from left to right.
Assume 0-based indexing.
Assume each row to be sorted by values.
Expected time complexity is O(rows + columns).


Code - 

 public int solve(int[][] A) {

         int n = A.length;
        int maxRowIndex = -1;
        int j = n - 1; 

        for (int i = 0; i < n; i++) {
         
            while (j >= 0 && A[i][j] == 1) {
                j--;
                maxRowIndex = i; 
            }
        }

        return maxRowIndex;

    }

Q - Minimum Swaps


Problem Description

Given an array of integers A and an integer B, find and return the minimum number of swaps required to bring all the numbers less than or equal to B together.

Note: It is possible to swap any two elements, not necessarily consecutive.



Problem Constraints

1 <= length of the array <= 100000
-109 <= A[i], B <= 109



Input Format

The first argument given is the integer array A.
The second argument given is the integer B.



Output Format

Return the minimum number of swaps.



Example Input

Input 1:

 A = [1, 12, 10, 3, 14, 10, 5]
 B = 8
Input 2:

 A = [5, 17, 100, 11]
 B = 20


Example Output

Output 1:

 2
Output 2:

 1


Example Explanation

Explanation 1:

 A = [1, 12, 10, 3, 14, 10, 5]
 After swapping  12 and 3, A => [1, 3, 10, 12, 14, 10, 5].
 After swapping  the first occurence of 10 and 5, A => [1, 3, 5, 12, 14, 10, 10].
 Now, all elements less than or equal to 8 are together.
Explanation 2:

 A = [5, 17, 100, 11]
 After swapping 100 and 11, A => [5, 17, 11, 100].
 Now, all elements less than or equal to 20 are together.

 Appraoch - 

 First, count the number of elements <= B. Let the count comes out to be X.

Create a window of first X elements. To find the number of swaps to bring all elements <= B together in the first window,
you just need to find count of elements > B in first window.
So, count of swaps required in 1 window = count of elements greater than B in that window.

For every window, find the count of elements greater than B, using sliding window technique.

Time Complexity: O(N)
Space Complexity: O(1)

Code - 

  public int solve(int[] A, int B) {

         int n = A.length;
        
       
        int countGood = 0;
        for (int num : A) {
            if (num <= B) {
                countGood++;
            }
        }

       
        int bad = 0;
        for (int i = 0; i < countGood; i++) {
            if (A[i] > B) {
                bad++;
            }
        }

        int minSwaps = bad;

       
        for (int i = 1, j = countGood; j < n; i++, j++) {
            if (A[i - 1] > B) bad--; 
            if (A[j] > B) bad++;    
            minSwaps = Math.min(minSwaps, bad);
        }

        return minSwaps;
    }


Q -  First Missing Integer


Problem Description

Given an unsorted integer array, A of size N. Find the first missing positive integer.





Note: Your algorithm should run in O(n) time and use constant space.







Problem Constraints

1 <= N <= 1000000

-109 <= A[i] <= 109



Input Format

First argument is an integer array A.



Output Format

Return an integer denoting the first missing positive integer.



Example Input

Input 1:

[1, 2, 0]
Input 2:

[3, 4, -1, 1]
Input 3:

[-8, -7, -6]






Example Output

Output 1:

3
Output 2:

2
Output 3:

1






Example Explanation

Explanation 1:

A = [1, 2, 0]
First positive integer missing from the array is 3.
Explanation 2:

A = [3, 4, -1, 1]
First positive integer missing from the array is 2.
Explanation 3:

A = [-8, -7, -6]
First positive integer missing from the array is 1.

Approach - 

Note: numbers A[i]<=0 and A[i]>N ( N being the size of the array ) are not important to us since the missing positive integer will be in the range [1, N+1].

The answer will be N+1 only if all of the elements of the array are exact one occurrence of [1, N].

Creating buckets would have
 been an easy solution if using extra space was allowed.

An array of size N initialized to 0 would have been created.

For every value A[i], which lies in the range [1, N], its count in the array would have been incremented.

Finally, traversing the array would help to find the first array position with value 0, and that will be our answer.
However, usage of buckets is not allowed; can we use the existing array as a bucket somehow?

Now, since additional space is not allowed either, the given array itself needs to be used to track it.

It may be helpful to use the fact that the size of the set we are looking to track is [1, N]

which happens to be the same size as the size of the array.

This means we can use the array to track these elements.

We traverse the array, and if A[i] is in [1, N] range, we try to put in the index of same value in the array.

Time complexity : O(N)
Auxiliary Space : O(1)


Code - 

public int firstMissingPositive(int[] A) {

         int n = A.length;

      
        for (int i = 0; i < n; i++) {
            while (A[i] > 0 && A[i] <= n && A[A[i] - 1] != A[i]) {
             
                int temp = A[i];
                A[i] = A[temp - 1];
                A[temp - 1] = temp;
            }
        }

     
        for (int i = 0; i < n; i++) {
            if (A[i] != i + 1) {
                return i + 1;
            }
        }

    
        return n + 1;

    }


Q - Merge Sorted Overlapping Intervals - 2

Problem Description

You are given a collection of intervals A in a 2-D array format, where each interval is represented by a pair of integers `[start, end]`. The intervals are sorted based on their start values.

Your task is to merge all overlapping intervals and return the resulting set of non-overlapping intervals.


Problem Constraints

1 <= len(A) <= 100000.
1 <= A[i][0] <= A[i][1] <= 100000

A is sorted based on the start value (A[i][0])



Input Format

First argument is a list of intervals in 2-Dimentional Array.



Output Format

Return the sorted list of intervals after merging all the overlapping intervals.



Example Input

Input 1:

[ [1, 3], [2, 6], [8, 10], [15, 18] ]
Input 2:

[ [2, 10], [4, 9], [6, 7] ]


Example Output

Output 1:

[ [1, 6], [8, 10], [15, 18] ]
Output 2:

[ [2, 10] ]


Example Explanation

Explanation 1:

Merge intervals [1,3] and [2,6] -> [1,6].
so, the required answer after merging is [1,6],[8,10],[15,18].
No more overlapping intervals present.
Explanation 2:

Merge intervals [2, 10], [4, 9], [6, 7] as [2,10].
Since [4, 9] and [6, 7] is overlapping inside the interval [2, 10].

so, the required answer after merging is [2, 10].

Approach - 

Given all the intervals, you need to figure out the sequence of intervals which intersect.

Lets see how we check if interval 1 (a,b) intersects with interval 2 (c,d):

Overlap case :

a---------------------b          OR             a------b
            c-------------------d           c------------------d
Nonoverlap case :

a--------------------b   c------------------d
If max(a,c) > min(b,d), then the intervals do not overlap. Otherwise, they overlap.

Do you think it will be easier to solve if you could sort the intervals based on the starting point?

First lets sort the array based on the starting point , if starting points are equal then based on ending point.
We can maintain two variables cur_start and cur_end where cur_start is the left most point of the current segment and cur_end is rightmost point of the current segment.
Set cur_start to the starting point of the first element and cur_end to the ending point of the first element.

Now we iterate from 1 to n-1 and for every i we check the following
if A[i][0] <= cur_end
This means i’th interval overlapps with the current interval, so we can add this to the current interval
else
This means the i’th interval doesnt overlapp with the current interval, therefore we can add the current interval to our answer and make a new interval i.e. set cur_start=A[i][0] and cur_end=A[i][1]

Lastly dont forget to add the current interval to our answer.

Time Complexity : O(N)
Space Complexity : O(N)
where N is the size of the intervals array


Code - 

public int[][] solve(int[][] A) {

        int cs = A[0][0];
        int ce = A[0][1];

        ArrayList<int[]> ans = new ArrayList<>();

        int j=0;

        for( int i =1; i <A.length; i++){
            int s = A[i][0];
            int e = A[i][1];


            if( s <= ce){ 
                // overlap found
                cs = Math.min(cs, s);
                ce = Math.max(ce, e);

            }else{
                
                ans.add(new int[]{cs, ce});
                cs = s;
                ce = e;

            }
        }

            ans.add(new int[]{cs, ce});

        return ans.toArray(new int[0][]);
    }


Q - Merge Intervals - 2

Problem Description

You have a set of non-overlapping intervals. You are given a new interval [start, end], insert this new interval into the set of intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.



Problem Constraints

0 <= |intervals| <= 105



Input Format

First argument is the vector of intervals

second argument is the new interval to be merged



Output Format

Return the vector of intervals after merging



Example Input

Input 1:

Given intervals [1, 3], [6, 9] insert and merge [2, 5] .
Input 2:

Given intervals [1, 3], [6, 9] insert and merge [2, 6] .


Example Output

Output 1:

 [ [1, 5], [6, 9] ]
Output 2:

 [ [1, 9] ]


Example Explanation

Explanation 1:

(2,5) does not completely merge the given intervals
Explanation 2:

(2,6) completely merges the given intervals


Approach - 

Have you covered the following corner cases :

1) Size of interval array as 0.

2) newInterval being an interval preceding all intervals in the array.

    Given interval (3,6),(8,10), insert and merge (1,2)
3) newInterval being an interval succeeding all intervals in the array.

    Given interval (1,2), (3,6), insert and merge (8,10)
4) newInterval not overlapping with any interval and falling in between 2 intervals in the array.

    Given interval (1,2), (8,10) insert and merge (3,6) 
5) newInterval covering all given intervals.

    Given interval (3, 5), (7, 9) insert and merge (1, 10)
Time Complexity: O(N)
Space Complexity: O(1)


Code - 

public int[][] insert(int[][] A, int[] B) {

        int cs = B[0];
        int ce = B[1];

        ArrayList<int[]> ans = new ArrayList<>();

        for( int i=0; i < A.length; i++){
            int s = A[i][0];
            int e = A[i][1];

            if( ce < s){
                ans.add(new int[]{cs, ce});

                for( int j=i; j<A.length; j++){
                    ans.add(A[j]);
                }

                return ans.toArray(new int[0][]);
            }

            if( e < cs ){
                ans.add(A[i]);
            }else {
                cs = Math.min( cs, s);
                ce = Math.max(ce, e);
            }
        }

        ans.add(new int[]{cs, ce});

        return ans.toArray(new int[0][]);
    }


    Q - Next Permutation


Problem Description

Implement the next permutation, which rearranges numbers into the numerically next greater permutation of numbers for a given array A of size N.



If such arrangement is not possible, it must be rearranged as the lowest possible order, i.e., sorted in ascending order.

NOTE:



The replacement must be in-place, do not allocate extra memory.
DO NOT USE LIBRARY FUNCTION FOR NEXT PERMUTATION. Use of Library functions will disqualify your submission retroactively and will give you penalty points.


Problem Constraints

1 <= N <= 5 * 105

1 <= A[i] <= 109



Input Format

The first and the only argument of input has an array of integers, A.



Output Format

Return an array of integers, representing the next permutation of the given array.



Example Input

Input 1:

 A = [1, 2, 3]
Input 2:

 A = [3, 2, 1]


Example Output

Output 1:

 [1, 3, 2]
Output 2:

 [1, 2, 3]


Example Explanation

Explanation 1:

 Next permutaion of [1, 2, 3] will be [1, 3, 2].
Explanation 2:

 No arrangement is possible such that the number are arranged into the numerically next greater permutation of numbers.
 So will rearranges it in the lowest possible order.


 Appraoch - 

 It might help to write down the next permutation on paper to see how and when the sequence changes.

You’ll realize the following pattern :

The suffix which gets affected is in descending order before the change.

A swap with the smaller element happens, and then we reverse the affected suffix.

    1 2 3 -> 1 3 2   // Suffix being just the 3. 

    1 2 3 6 5 4  -> 1 2 4 3 5 6 // Suffix being 6 5 4 in this case. 


Code - 

 public int[] nextPermutation(int[] A) {

        int n=A.length;
        int index=-1;

        // finding the pivot 
        for( int i = n-2; i >= 0; i--){

            if(A[i] < A[i+1]){
                index = i;
                break;
            }
        }

        if( index == -1){
            reverseArray(A, 0, n-1);
            return A;
        }

        for( int i = n-1; i >= index; i--){
            if(A[i] > A[index]){
                swap(A, i, index);
                break;
            }
        }

        reverseArray(A, index + 1, n-1 );
        return A;
    }

    public void swap(int[] A, int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }

    public void reverseArray(int[] A, int i, int j){

        while( i <= j){

            int temp = A[i];
            A[i] = A[j];
            A[j] = temp;
            j--;
            i++;
        }
    }


Q - Number of Digit One

Problem Description

Given an integer A, find and return the total number of digit 1 appearing in all non-negative integers less than or equal to A.



Problem Constraints

0 <= A <= 109



Input Format

The only argument given is the integer A.



Output Format

Return the total number of digit 1 appearing in all non-negative integers less than or equal to A.



Example Input

Input 1:

 A = 10
Input 2:

 A = 11


Example Output

Output 1:

 2
Output 2:

 4


Example Explanation

Explanation 1:

Digit 1 appears in 1 and 10 only and appears one time in each. So the answer is 2.
Explanation 2:

Digit 1 appears in 1(1 time) , 10(1 time) and 11(2 times) only. So the answer is 4.


Appraoch - 

The brute force solution of traversing all numbers from 1 to A and counting the number of 1s in each number will not pass with the given constraints.

Try to approach the problem in a different way.

Let’s just figure out the number of 1s at one’s place, a number of 1s in second place, and so on. We will add all these occurrences of 1s.

At one’s place:
up to 10, there is 1 one.
up to 20, there are 2 one’s.
.
.
up to 131, there are 14 one’s
up to 13x(x>1), there are 14 one’s.

Number of 1’s at one’s position = (n/10) + (n%10!=0)

Try to find the formula for ten’s place, hundred’s place, and so on.

Solution can be summarised into 4 steps:
1) Initialize ans = 0
2) Iterate over i from 1 to n incrementing by 10 times in each iteration.
3) Add (n / (i * 10 ) ) * i to ans after each (i * 10) interval.
4) Add min( max((n mod (i * 10) – i + 1, 0), i) to ans.


Code - 

   public int solve(int A) {



int ans =0;

for( int i=1; i<= A; i*=10){

int div = i * 10;
int q = A/div;
int rem = A%div;

ans += q * i;

if( rem >= i) {
ans += Math.min( rem-i+1, i);
}
}

return ans;



    }