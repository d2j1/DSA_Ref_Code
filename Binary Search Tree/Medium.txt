
Q - Sorted Array To Balanced BST

Problem Description

Given an array where elements are sorted in ascending order, convert it to a height Balanced Binary Search Tree (BBST).

Balanced tree : a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.



Problem Constraints

1 <= length of array <= 100000



Input Format

First argument is an integer array A.



Output Format

Return a root node of the Binary Search Tree.



Example Input

Input 1:

 A : [1, 2, 3]
Input 2:

 A : [1, 2, 3, 5, 10]


 
Approach - 


Intuition and Approach

The sorted nature of the array gives a key insight:

Inorder traversal of a BST yields a sorted sequence.
Hence, if we take the middle element as the root,
its left side will automatically form the left subtree (smaller elements),
and right side will form the right subtree (larger elements).

Steps

Base Case:

If the array range is empty (start > end), return null.

Find Middle Element:

mid = (start + end) / 2

Create a node with value A[mid].

Recursive Construction:

Left subtree = build from A[start … mid-1]

Right subtree = build from A[mid+1 … end]

Return Root Node.


Time Complexity: O(N) — each element used exactly once.

Space Complexity: O(log N) — recursion stack (height of tree).



Code - 

public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public TreeNode sortedArrayToBST(final int[] A) {
        return build( A, 0 , A.length-1);
    }

    public TreeNode build(int[] A, int start, int end){

        if( start > end){
            return null;
        }

        int mid = (start + end)/2;

        TreeNode node = new TreeNode(A[mid]);

        node.left = build(A, start, mid-1);
        node.right = build(A, mid+1, end);

        return node;
    }
}

Q -  Delete a node in BST


Problem Description

Given a Binary Search Tree(BST) A. If there is a node with value B present in the tree delete it and return the tree.

Note - If there are multiple options, always replace a node by its in-order predecessor


Problem Constraints

2 <= No. of nodes in BST <= 105
1 <= value of nodes <= 109
Each node has a unique value


Input Format

The first argument is the root node of a Binary Search Tree A.
The second argument is the value B.


Output Format

Delete the given node if found and return the root of the BST.

Approach -

There are 3 possible cases when deleting a node:

 Case 1: Node is a Leaf Node (no children)

Simply delete the node — i.e., return null for that branch.

     5
    /
   3       ← delete(3)
→ becomes
     5

 Case 2: Node has Only One Child

Replace the node with its only child.

     5
    /
   3
    \
     4    ← delete(3)
→ becomes
     5
    /
   4

 Case 3: Node has Two Children

This is the tricky case.

You have two options:

Replace node with inorder successor (minimum in right subtree)

Or replace node with inorder predecessor (maximum in left subtree)

 The problem specifically says to use the inorder predecessor.

So steps:

Find the maximum node in the left subtree → inorder predecessor.

Copy its value into the current node.

Delete that predecessor node recursively from the left subtree.

 Approach Summary

Traverse the BST to find the node with value B.

If B < root.val, go left.

If B > root.val, go right.

If B == root.val, we found the node to delete.

Apply deletion logic:

No child → return null

One child → return that child

Two children:

Find inorder predecessor (max in left subtree)

Copy its value into the current node

Recursively delete that predecessor from the left subtree

Return the root after modifications.

Code - 

public class Solution {
    public TreeNode solve(TreeNode A, int B) {

        if( A == null) return null;

        if( B < A.val){
            A.left = solve( A.left, B);
        }else if( B > A.val){
            A.right = solve(A.right, B);
        }else{

            // node found

            // case 1 - no children
            if( A.left == null && A.right == null){
                return null;
            }

            // case 2 - one child

            else if( A.left == null){
                return A.right;
            }else if(  A.right == null){
                return A.left;
            }

            // case 3 - two childrens

            else{

                TreeNode predecessor = findMaxOnLeft(A.left);
                A.val = predecessor.val;
                A.left = solve( A.left, predecessor.val); // delete predecessor
            }

        }

        return A;


        }
    

    public TreeNode findMaxOnLeft(TreeNode node){
        while(node.right != null ){
            node = node.right;
        }

        return node;
    }


}


