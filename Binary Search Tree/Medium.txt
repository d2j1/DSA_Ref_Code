
Q - Sorted Array To Balanced BST

Problem Description

Given an array where elements are sorted in ascending order, convert it to a height Balanced Binary Search Tree (BBST).

Balanced tree : a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.



Problem Constraints

1 <= length of array <= 100000



Input Format

First argument is an integer array A.



Output Format

Return a root node of the Binary Search Tree.



Example Input

Input 1:

 A : [1, 2, 3]
Input 2:

 A : [1, 2, 3, 5, 10]


 
Approach - 


Intuition and Approach

The sorted nature of the array gives a key insight:

Inorder traversal of a BST yields a sorted sequence.
Hence, if we take the middle element as the root,
its left side will automatically form the left subtree (smaller elements),
and right side will form the right subtree (larger elements).

Steps

Base Case:

If the array range is empty (start > end), return null.

Find Middle Element:

mid = (start + end) / 2

Create a node with value A[mid].

Recursive Construction:

Left subtree = build from A[start ‚Ä¶ mid-1]

Right subtree = build from A[mid+1 ‚Ä¶ end]

Return Root Node.


Time Complexity: O(N) ‚Äî each element used exactly once.

Space Complexity: O(log N) ‚Äî recursion stack (height of tree).



Code - 

public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public TreeNode sortedArrayToBST(final int[] A) {
        return build( A, 0 , A.length-1);
    }

    public TreeNode build(int[] A, int start, int end){

        if( start > end){
            return null;
        }

        int mid = (start + end)/2;

        TreeNode node = new TreeNode(A[mid]);

        node.left = build(A, start, mid-1);
        node.right = build(A, mid+1, end);

        return node;
    }
}

Q -  Delete a node in BST


Problem Description

Given a Binary Search Tree(BST) A. If there is a node with value B present in the tree delete it and return the tree.

Note - If there are multiple options, always replace a node by its in-order predecessor


Problem Constraints

2 <= No. of nodes in BST <= 105
1 <= value of nodes <= 109
Each node has a unique value


Input Format

The first argument is the root node of a Binary Search Tree A.
The second argument is the value B.


Output Format

Delete the given node if found and return the root of the BST.

Approach -

There are 3 possible cases when deleting a node:

 Case 1: Node is a Leaf Node (no children)

Simply delete the node ‚Äî i.e., return null for that branch.

     5
    /
   3       ‚Üê delete(3)
‚Üí becomes
     5

 Case 2: Node has Only One Child

Replace the node with its only child.

     5
    /
   3
    \
     4    ‚Üê delete(3)
‚Üí becomes
     5
    /
   4

 Case 3: Node has Two Children

This is the tricky case.

You have two options:

Replace node with inorder successor (minimum in right subtree)

Or replace node with inorder predecessor (maximum in left subtree)

 The problem specifically says to use the inorder predecessor.

So steps:

Find the maximum node in the left subtree ‚Üí inorder predecessor.

Copy its value into the current node.

Delete that predecessor node recursively from the left subtree.

 Approach Summary

Traverse the BST to find the node with value B.

If B < root.val, go left.

If B > root.val, go right.

If B == root.val, we found the node to delete.

Apply deletion logic:

No child ‚Üí return null

One child ‚Üí return that child

Two children:

Find inorder predecessor (max in left subtree)

Copy its value into the current node

Recursively delete that predecessor from the left subtree

Return the root after modifications.

Code - 

public class Solution {
    public TreeNode solve(TreeNode A, int B) {

        if( A == null) return null;

        if( B < A.val){
            A.left = solve( A.left, B);
        }else if( B > A.val){
            A.right = solve(A.right, B);
        }else{

            // node found

            // case 1 - no children
            if( A.left == null && A.right == null){
                return null;
            }

            // case 2 - one child

            else if( A.left == null){
                return A.right;
            }else if(  A.right == null){
                return A.left;
            }

            // case 3 - two childrens

            else{

                TreeNode predecessor = findMaxOnLeft(A.left);
                A.val = predecessor.val;
                A.left = solve( A.left, predecessor.val); // delete predecessor
            }

        }

        return A;


        }
    

    public TreeNode findMaxOnLeft(TreeNode node){
        while(node.right != null ){
            node = node.right;
        }

        return node;
    }


}


Q - Two Sum BST  (Hard)


Problem Description

Given a binary search tree A, where each node contains a positive integer, and an integer B, you have to find whether or not there exist two different nodes X and Y such that X.value + Y.value = B.

Return 1 to denote that two such nodes exist. Return 0, otherwise.



Problem Constraints

1 <= size of tree <= 100000

1 <= B <= 109



Input Format

First argument is the head of the tree A.

Second argument is the integer B.



Output Format

Return 1 if such a pair can be found, 0 otherwise.



Example Input

Input 1:

         10
         / \
        9   20

B = 19
Input 2:

 
          10
         / \
        9   20

B = 40


Example Output

Output 1:

 1
Output 2:

 0


Example Explanation

Explanation 1:

 10 + 9 = 19. Hence 1 is returned.
Explanation 2:

 No such pair exists.


 Approach - 

 
BF - 


Do inorder traversal of the tree, we will get sorted array of BST node values. Now use two pointer to find out two node sums - 

i=0, j=n-1

while( i <= j ){
	
	if( A[i] + A[j] == target) return 1;
	
	
	if( A[i] + A[j] > target){
	j--;
	}else {
	i++;
	}

}

return 0;


TC - O(N)
SC - O(N)


Optimized - 

Using the BST iterator.

This code uses two stacks to simulate two BST iterators ‚Äî

One moves from smallest to largest (inorder traversal)

The other moves from largest to smallest (reverse inorder traversal)

This is the space-optimized O(H) approach ‚Äî but implemented manually, without defining a separate iterator class.

‚öôÔ∏è Step-by-Step Explanation
1. Two stacks for two directions
Stack<TreeNode> stack1 = new Stack<>();
Stack<TreeNode> stack2 = new Stack<>();
TreeNode current1 = A;  // For normal inorder (ascending)
TreeNode current2 = A;  // For reverse inorder (descending)


stack1 and current1: used to traverse inorder (smallest ‚Üí largest)

stack2 and current2: used to traverse reverse inorder (largest ‚Üí smallest)

These two will act like left and right pointers in a sorted array.

2. The Outer While Loop
while (((stack1.size() > 0) || current1 != null) || (stack2.size() > 0) || current2 != null)


This continues as long as either iterator still has nodes left to process.

3. Building the Iterators
if (current1 != null || current2 != null) {
    if (current1 != null) {
        stack1.push(current1);
        current1 = current1.left; // go left for inorder
    }
    if (current2 != null) {
        stack2.push(current2);
        current2 = current2.right; // go right for reverse inorder
    }
}


This part pushes nodes along both traversal directions:

For inorder (smallest): keep pushing left nodes.

For reverse inorder (largest): keep pushing right nodes.

So after this step:

The top of stack1 is the next smallest element

The top of stack2 is the next largest element

4. When both currents are null

When both traversal fronts reach a leaf (i.e., current1 == null and current2 == null), we‚Äôve reached valid candidate nodes from both ends.

TreeNode node1 = stack1.peek();
TreeNode node2 = stack2.peek();


node1 is the current smallest unprocessed node,
node2 is the current largest unprocessed node.

5. Compute the sum
int sum = node1.val + node2.val;


Now check:

If both nodes are the same ‚Üí we can‚Äôt use the same node twice ‚Üí return 0.

If sum == B ‚Üí found the pair ‚Üí return 1.

If sum < B ‚Üí need a larger value ‚Üí move the inorder iterator forward.

If sum > B ‚Üí need a smaller value ‚Üí move the reverse inorder iterator backward.

6. Move the appropriate iterator

If the sum is smaller:

stack1.pop();
current1 = node1.right; // move inorder forward (to next greater)


If the sum is greater:

stack2.pop();
current2 = node2.left; // move reverse inorder backward (to next smaller)


These steps continue until either:

A valid pair is found ‚Üí return 1

Both iterators cross ‚Üí loop ends ‚Üí return 0

üß© Dry Run Example

Tree:

        10
       /  \
      9   20
B = 19

Initialization

stack1 = [], stack2 = []

current1 = 10, current2 = 10

Step 1: Push left (for inorder) and right (for reverse inorder)

Push 10 ‚Üí go left ‚Üí push 9 (stack1 = [10, 9])

Push 10 ‚Üí go right ‚Üí push 20 (stack2 = [10, 20])

Now:

node1 = 9 (peek of stack1)

node2 = 20 (peek of stack2)

sum = 9 + 20 = 29 > 19

‚Üí sum > B ‚Üí move reverse inorder:

Pop 20 ‚Üí current2 = 20.left = null

Step 2:

node1 = 9, node2 = 10

sum = 9 + 10 = 19 ‚úÖ
‚Üí return 1


Code - 


public class Solution {
    public int t2Sum(TreeNode A, int B) {
        Stack<TreeNode> stack1 = new Stack<TreeNode>();
        Stack<TreeNode> stack2 = new Stack<TreeNode>();
        TreeNode current1 = A;
        TreeNode current2 = A;

        while (((stack1.size() > 0) || current1 != null) || (stack2.size() > 0) || current2 != null) {
            if (current1 != null || current2 != null) {
                if (current1 != null) {
                    stack1.push(current1);
                    current1 = current1.left;
                }
                if (current2 != null) {
                    stack2.push(current2);
                    current2 = current2.right;
                }
            } else {
                if (stack1.size() == 0 || stack2.size() == 0)
                    break;
                TreeNode node1 = stack1.peek();
                TreeNode node2 = stack2.peek();

                int sum = node1.val + node2.val;
                if (node1.val == node2.val) {
                    return 0;
                } else if (sum == B)
                    return 1;
                else if (sum < B) {
                    stack1.pop();
                    current1 = node1.right;
                } else {
                    stack2.pop();
                    current2 = node2.left;
                }
            }
        }
        return 0;
    }
}


Q - Check for BST with One Child


Problem Description

Given preorder traversal of a binary tree, check if it is possible that it is also a preorder traversal of a Binary Search Tree (BST), where each internal node (non-leaf nodes) have exactly one child.



Problem Constraints

1 <= number of nodes <= 100000



Input Format

First and only argument is an integer array denoting the preorder traversal of binary tree.



Output Format

Return a string "YES" if true else "NO".



Example Input

Input 1:

 A : [4, 10, 5, 8]
Input 2:

 A : [1, 5, 6, 4]


Example Output

Output 1:

 "YES"
Output 2:

 "NO"


Example Explanation

Explanation 1:

 The possible BST is:
            4
             \
             10
             /
             5
              \
              8
Explanation 2:

 There is no possible BST which have the above preorder traversal.


 Approach - 

 In a BST:

Left subtree values < root

Right subtree values > root

In preorder traversal (Root ‚Üí Left ‚Üí Right),
for a BST where each node has only one child, all nodes except the last will have exactly one subtree (either left or right).

That means:

The next node in preorder will always lie in the same direction (either all smaller or all greater) compared to future nodes.

So, for every node, all subsequent nodes in preorder must be either:

All greater than it (if it has only right child), or

All smaller than it (if it has only left child).

üí° Core Observation

For such a tree to be valid:

Each element (except the last) must have the next element either greater or smaller,
and all remaining elements must lie on the same side relative to it.

Example:

A = [4, 10, 5, 8]


‚úÖ Check manually:

For 4 ‚Üí next = 10 (>4), last = 8 (>4) ‚Üí same side ‚úÖ

For 10 ‚Üí next = 5 (<10), last = 8 (<10) ‚Üí same side ‚úÖ

For 5 ‚Üí next = 8 (>5), last = 8 (>5) ‚Üí same side ‚úÖ
Hence ‚ÄúYES‚Äù.

‚öôÔ∏è Efficient Approach (O(N), O(1) Space)

We can check using range tracking as we move through the preorder.

Intuition:

Keep track of the allowed range (min, max) for node values as we simulate preorder traversal.

Initially:

min = Integer.MIN_VALUE

max = Integer.MAX_VALUE

For every next value in preorder:

If it‚Äôs less than current value, we move left ‚Üí update max = current

If it‚Äôs greater than current value, we move right ‚Üí update min = current

If a value violates min < val < max, then BST rule breaks ‚Üí return ‚ÄúNO‚Äù.

If we reach the end ‚Üí ‚ÄúYES‚Äù.


Code - 

  public String solve(int[] A) {

              int n = A.length;
        if (n <= 2) return "YES"; // With <=2 nodes, always valid
        
        int min = Integer.MIN_VALUE;
        int max = Integer.MAX_VALUE;
        
        for (int i = 1; i < n; i++) {
            if (A[i] < A[i - 1]) {
                // Moving to left subtree
                if (A[i] < min) return "NO";
                max = A[i - 1];
            } else {
                // Moving to right subtree
                if (A[i] > max) return "NO";
                min = A[i - 1];
            }
        }
        
        return "YES";
    }

    

