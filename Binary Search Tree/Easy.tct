

Q - Valid Binary Search Tree

Problem Description

You are given a binary tree represented by root A. You need to check if it is a Binary Search Tree or not.


Assume a BST is defined as follows:

1) The left subtree of a node contains only nodes with keys less than the node's key.

2) The right subtree of a node contains only nodes with keys greater than the node's key.

3) Both the left and right subtrees must also be binary search trees.





Problem Constraints

1 <= Number of nodes in binary tree <= 105





0 <= node values <= 232-1





Input Format

First and only argument is head of the binary tree A.



Output Format

Return 0 if false and 1 if true.


Appraoch - 


BF - 

for every node, 

find max in left subtree and find min in right subtree. 

if( value of node > max in left subtree and value of node < min in right subtree ) then that node is valid subtree.


TC - O(n^2)
SC - O(1)

optimization idea - 

We pass down the valid range (min, max) for every node.


Start from root with min = -∞, max = +∞.

At each node:

If node is null, return true (base case).

If node.val <= min or node.val >= max, return false.

Recurse for:

Left child → (min, node.val)

Right child → (node.val, max)

If both subtrees are valid, return true.


Code - 

public class Solution {
    public int isValidBST(TreeNode A) {

        return validateTree(A, Long.MIN_VALUE, Long.MAX_VALUE) ? 1:0;
    }


    public boolean validateTree(TreeNode root, long min, long max){

        if( root == null) return true;

        if( root.val <= min || root.val >= max){
            return false;
        }

        boolean f1 = validateTree(root.left, min, root.val);
        boolean f2 = validateTree(root.right, root.val, max);

        return f1 && f2;

    }


}



Q - Search in BST

Problem Description

Given a Binary Search Tree A. Check whether there exists a node with value B in the BST.


Problem Constraints

1 <= Number of nodes in binary tree <= 105

0 <= B <= 106



Input Format

First argument is a root node of the binary tree, A.

Second argument is an integer B.



Output Format

Return 1 if such a node exist and 0 otherwise

Appraoch - 

Search in BST (returning boolean)

We’ll use the same BST property:

If the target B is smaller than the current node’s value, search in the left subtree.

If larger, search in the right subtree.

If equal, return true.

If you reach a null node, it means the value doesn’t exist → return false.


Code - 


public class Solution {
    public int solve(TreeNode A, int B) {

        return search(A, B) ? 1 :0;
    }

    public boolean search(TreeNode node, int target){

        if(node == null){
            return false;
        }

        if(node.val == target ){
            return true;
        }
        
         if(  target < node.val){
            return search(node.left, target);
        }else{
            return search(node.right, target);
        }


    }
}


