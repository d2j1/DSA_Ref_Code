Q - Special Index

Problem Description

Given an array, arr[] of size N, the task is to find the count of array indices such that removing an element from these indices makes the sum of even-indexed and odd-indexed array elements equal.



Problem Constraints

1 <= N <= 105
-105 <= A[i] <= 105
Sum of all elements of A <= 109


Input Format

First argument contains an array A of integers of size N


Output Format

Return the count of array indices such that removing an element from these indices makes the sum of even-indexed and odd-indexed array elements equal.



Example Input

Input 1:
A = [2, 1, 6, 4]
Input 2:

A = [1, 1, 1]






Example Output

Output 1:
1
Output 2:

3






Example Explanation

Explanation 1:
Removing arr[1] from the array modifies arr[] to { 2, 6, 4 } such that, arr[0] + arr[2] = arr[1]. 
Therefore, the required output is 1. 
Explanation 2:

Removing arr[0] from the given array modifies arr[] to { 1, 1 } such that arr[0] = arr[1] 
Removing arr[1] from the given array modifies arr[] to { 1, 1 } such that arr[0] = arr[1] 
Removing arr[2] from the given array modifies arr[] to { 1, 1 } such that arr[0] = arr[1] 
Therefore, the required output is 3.

Approach - 

Based on the observation that removing any element from the
 given array makes even indices of succeeding elements 
as odd and odd indices of the succeeding elements as even. 

create prefix sum arrays of even and odd indices and
find out the sum of elements.

Code - 

 public int solve(int[] A) {
        
        int n= A.length;

        int[] pfodd = new int[n];
        int[] pfeven = new int[n];

        pfeven[0] = A[0];

        for( int i =1; i<n; i++){
            if( i%2 == 0){
                pfeven[i] = pfeven[i-1] + A[i];
            }else{
                pfeven[i] = pfeven[i-1];
            }
        }

        pfodd[0]=0;

        for( int i =1; i<n; i++){
            if( i%2 == 1){
                pfodd[i] = pfodd[i-1] + A[i];
            }else{
                pfodd[i] = pfodd[i-1];
            }
        }


        int sumOdd=0;
        int sumEven=0;
        int cnt=0;

        for( int i =0; i < n; i++){

            sumOdd=0;
            sumEven=0;

            if( i == 0 ){
                sumEven = pfodd[n-1] - pfodd[0];
                sumOdd = pfeven[n-1] - pfeven[0];
            }else if( i == n-1){
                sumOdd = pfodd[n-2];
                sumEven = pfeven[n-2];
            }else{

                sumEven = pfeven[i-1] + pfodd[n-1] - pfodd[i];
                sumOdd = pfeven[n-1] - pfeven[i] + pfodd[i-1];
            }

            if( sumEven == sumOdd){
                cnt++;
            }
        }

        return cnt;
    }

    Approach 2 - 

    Based on the observation that removing any element from the given array makes even indices of succeeding elements 
as odd and odd indices of the succeeding elements as even. 
Follow the steps below to solve the problem:

Initialize two variables, say evenSum and oddSum,
to store the sum of odd-indexed and even-indexed elements of the given array respectively.

Traverse the array using variable i.
Remove every ith element of the array and update the sum of the remaining even-indexed elements 
and the odd-indexed elements based on the above observation. Check if the sums are equal or not. 
If found to be true, then increment the count.

Finally, print the count obtained. Check out the complete solution for more clarity.


Time complexity : O(N) 
Space Complexity : O(1)

Code - 

   private int cntIndexesToMakeBalance(int arr[], int n)
    {
        if (n == 1) {
            return 1;
        }
     
        if (n == 2)
            return 0;
     
        int sumEven = 0;
        int sumOdd = 0;
     
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                sumEven += arr[i];
            }
            else {
                sumOdd += arr[i];
            }
        }
     
        int currOdd = 0;
        int currEven = arr[0];
        int res = 0;
        int newEvenSum = 0;
        int newOddSum = 0;
     
        for (int i = 1; i < n - 1; i++) {
            if (i % 2 == 1) {
                currOdd += arr[i];
                newEvenSum = currEven + sumOdd
                             - currOdd;
                newOddSum = currOdd + sumEven
                            - currEven - arr[i];
            }
            else {
                currEven += arr[i];
                newOddSum = currOdd + sumEven
                            - currEven;
                newEvenSum = currEven + sumOdd
                             - currOdd - arr[i];
            }
            if (newEvenSum == newOddSum) {
                res++;
            }
        }
        if (sumOdd == sumEven - arr[0]) {
            res++;
        }
        if (n % 2 == 1) {
            if (sumOdd == sumEven - arr[n - 1]) {
                res++;
            }
        }
        else {
            if (sumEven == sumOdd - arr[n - 1]) {
                res++;
            }
        }
        return res;
    }
 
    public int solve(int[] A) {
        int n = A.length;
        return cntIndexesToMakeBalance(A, n);
    }


Q - Equilibrium index of an array

Problem Description

You are given an array A of integers of size N.

Your task is to find the equilibrium index of the given array

The equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.

If there are no elements that are at lower indexes or at higher indexes, then the corresponding sum of elements is considered as 0.

Note:

Array indexing starts from 0.
If there is no equilibrium index then return -1.
If there are more than one equilibrium indexes then return the minimum index.




Problem Constraints

1 <= N <= 105
-105 <= A[i] <= 105


Input Format

First arugment is an array A .


Output Format

Return the equilibrium index of the given array. If no such index is found then return -1.


Example Input

Input 1:
A = [-7, 1, 5, 2, -4, 3, 0]
Input 2:

A = [1, 2, 3]


Example Output

Output 1:
3
Output 2:

-1


Approach - Use prefix sum.

Code - 

   public int solve(int[] A) {

        int[] pf = new int[A.length];

        pf[0] = A[0];

        for( int i =1; i < A.length; i++){
            pf[i] = pf[i-1] + A[i];
        }

        int sumL=0;
        int sumR=0;

        for( int i=0; i < A.length; i++){

            sumL=0;
            sumR=0;

            if( i == 0){
                sumR = pf[pf.length-1] - pf[i];
            }else if( i == A.length -1) {
              sumL = pf[i-1];  
            }else{
                sumR = pf[pf.length-1] - pf[i];
                sumL = pf[i-1];  
            }

            if( sumL == sumR ){
                return i;
            }
        }

        return -1;
    }

    