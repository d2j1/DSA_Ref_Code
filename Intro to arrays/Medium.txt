Q - Array Rotation

Problem Description

Given an integer array A of size N and an integer B, you have to return the same array after rotating it B times towards the right.


Problem Constraints

1 <= N <= 105
1 <= A[i] <=109
1 <= B <= 109


Input Format

The first argument given is the integer array A.
The second argument given is the integer B.


Output Format

Return the array A after rotating it B times to the right


Example Input

Input 1:

A = [1, 2, 3, 4]
B = 2
Input 2:

A = [2, 5, 6]
B = 1


Example Output

Output 1:

[3, 4, 1, 2]
Output 2:

[6, 2, 5]


Example Explanation

Explanation 1:

Rotate towards the right 2 times - [1, 2, 3, 4] => [4, 1, 2, 3] => [3, 4, 1, 2]
Explanation 2:

Rotate towards the right 1 time - [2, 5, 6] => [6, 2, 5]

Approach - 

BF - 

Take last element and move all elements from left to right
by one position and and keep this last element at the start of
the array.

do this B times and return the ans.

Optimised - 

Let n be the length of the array.
Rotating an array by n and 2 * n times gives the same results, i.e., rotating i or i % n times is the same.
So, we update B to B % n.

When we rotate the array B times, B elements from the back end of the array come to the front 
and the rest of the elements from the front shift backward.

In this approach, we firstly reverse all the elements of the array. 
Then, reversing the first B elements followed by reversing the rest N - B elements gives us the required result.

Time Complexity : O(N)
Space Complexity : O(1)

Code - 

   public int[] solve(int[] A, int B) {
    
    B = B % A.length;

    // reverse the 0 to B-1
    reverse(A, 0, A.length-1);

    // reverse the B to N-1
    reverse(A, 0, B-1);

    // reverse the entire array
    reverse(A, B , A.length-1);
    
    return A;
    }

    public static void reverse( int[] a, int l, int r){

        int temp=0;

        while(l<r){
            temp=a[l];
            a[l]=a[r];
            a[r]=temp;
            r--;
            l++;
        }

    }



Q -  Time to equality

Problem Description

Given an integer array A of size N. In one second, you can increase the value of one element by 1.

Find the minimum time in seconds to make all elements of the array equal.


Problem Constraints

1 <= N <= 1000000
1 <= A[i] <= 1000


Input Format

First argument is an integer array A.


Output Format

Return an integer denoting the minimum time to make all elements equal.


Example Input

A = [2, 4, 1, 3, 2]


Example Output

8


Example Explanation

We can change the array A = [4, 4, 4, 4, 4]. The time required will be 8 seconds.

Approach - 
Since we can only increase the element by 1, we should increase all elements up to the maximum element.
We can find the maximum element, and for finding the minimum number of moves, we should find the summation of the absolute difference of all 
elements with the maximum element.  

Code - 

    public int solve(int[] A) {

        int ans=0;
        int max=0;

        for( int i=0; i<A.length; i++){
            max = Math.max(A[i], max);
        }

        for( int i=0; i<A.length; i++){
            ans += max-A[i];
        }

        return ans;
    }

Q - Count of elements

Problem Description

Given an array A of N integers. 
Count the number of elements that have at least 1 elements greater than itself.


Problem Constraints

1 <= N <= 103
1 <= A[i] <= 109


Input Format

First and only argument is an array of integers A.


Output Format

Return the count of elements.


Example Input

Input 1:
A = [3, 1, 2]
Input 2:
A = [5, 5, 3]


Example Output

Output 1:
2
Output 2:
1


Example Explanation

Explanation 1:
The elements that have at least 1 element greater than itself are 1 and 2
Explanation 2:
The elements that have at least 1 element greater than itself is 3


Approach - 

We need to count the number of elements in the array 
that are not equal to the maximum value of the array.
We can traverse the array and get this count.

Time Complexity : O(N)
Space Complexity : O(1)


Code - 

   public int solve(int[] A) {

        int max = 0;
        int maxCnt=0;

        for( int i=0; i<A.length; i++){
            
            if( A[i] > max){
                max = A[i];
                maxCnt=1;
            }else if( A[i] == max){
                maxCnt++;
            }
        }
        return A.length-maxCnt;
    }


Q - Second Largest


Problem Description

You are given an integer array A. You have to find the second largest element/value in the array or report that no such element exists.


Problem Constraints

1 <= |A| <= 105


0 <= A[i] <= 109





Input Format

The first argument is an integer array A.





Output Format

Return the second largest element. If no such element exist then return -1.



Example Input

Input 1:

 A = [2, 1, 2] 
Input 2:

 A = [2]


Example Output

Output 1:

 1 
Output 2:

 -1 


Example Explanation

Explanation 1:

 First largest element = 2
 Second largest element = 1
Explanation 2:

 There is no second largest element in the array.

 Approach - 

 First, we iterate over each element in the list and find the largest element. Letâ€™s say max_elem.
Then, we again iterate over each element in the list using a for loop and find the largest element, but we also check if that element is equal to max_elem, if it is we skip it.

Code - 

   public int solve(int[] A) {

        int max=-1;
        int secondMax=-1;

        for(int i=0; i<A.length; i++){

            if( A[i] > max){
                secondMax=max;
                max = A[i];
            }else if( A[i] > secondMax && A[i] < max){
                secondMax=A[i];
            }

        }

        return secondMax;

    }

    
