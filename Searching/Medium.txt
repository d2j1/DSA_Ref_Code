Q - Matrix Search

Given a matrix of integers A of size N x M and an integer B. Write an efficient algorithm that searches for integer B in matrix A.

This matrix A has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than or equal to the last integer of the previous row.
Return 1 if B is present in A, else return 0.

NOTE: Rows are numbered from top to bottom, and columns are from left to right.



Problem Constraints

1 <= N, M <= 1000
1 <= A[i][j], B <= 106

Example Input

Input 1:

A = [ 
      [1,   3,  5,  7]
      [10, 11, 16, 20]
      [23, 30, 34, 50]  
    ]
B = 3
Input 2:

A = [   
      [5, 17, 100, 111]
      [119, 120, 127, 131]    
    ]
B = 3


Example Output

Output 1:

1
Output 2:

0

Code - 

public class Solution {
    public int searchMatrix(int[][] A, int B) {

        int rows=A.length, cols=A[0].length;

        int row=0;
        int col=cols-1;

        while(row<rows && col>=0){

            if(A[row][col] ==B){
                return 1;
            }else if( A[row][col] > B){
                col--;
            }else{
                row++;
            }
        }

        return 0;


    }
}

Q - Search for a Range

Given a sorted array of integers A (0-indexed) of size N, find the left most and the right most index of a given integer B in the array A.

Return an array of size 2, such that 
          First element = Left most index of B in A
          Second element = Right most index of B in A.
If B is not found in A, return [-1, -1].

Note : Note: The time complexity of your algorithm must be O(log n)..


Problem Constraints

1 <= N <= 106
1 <= A[i], B <= 109

Example Input

Input 1:

 A = [5, 7, 7, 8, 8, 10]
 B = 8
Input 2:

 A = [5, 17, 100, 111]
 B = 3


Example Output

Output 1:

 [3, 4]
Output 2:

 [-1, -1]


 Approach - Find out the left most index of B and then again find out 
 right most index of B using binary search and at the end return both indexes.

 Code - 

 public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int[] searchRange(final int[] A, int B) {

        int l=0, r=A.length-1;

        int start=-1;
        int end=-1;

        while( l <=r){

            int mid = (l+r)/2;

            if(A[mid] == B){
                
                start=mid;
                r = mid-1;
            }else if( A[mid] > B){
                r = mid-1;
            }else{
                l=mid+1;
            }
        }

        l=0;
        r=A.length-1;

        while( l<=r){
            int mid = (l+r)/2;

            if( A[mid] == B){
                l=mid+1;
                end=mid;
            }else if( A[mid] > B ){
                r=mid-1;
            }else{
                l = mid+1;
            }
        }

        int[] ans = new int[2];

        ans[0] = start;
        ans[1] = end;

        return ans;
    }
}

Q  -  Single Element in Sorted Array

Given a sorted array of integers A where every element appears twice except for one element which appears once, find and return this single element that appears only once.

Elements which are appearing twice are adjacent to each other.

NOTE: Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 10^9

Example Input

Input 1:

A = [1, 1, 7]
Input 2:

A = [2, 3, 3]


Example Output

Output 1:

 7
Output 2:

 2


 Approach - 
 
 observation - 

First occurence of the element is present at even index before unique element.

First occurence of the element is present at odd index after unique element.


Code - 

public class Solution {
    public int solve(int[] A) {
    

    if(A.length ==1){
        return A[0];
    }
    
    int l=0, r=A.length-1;
    int n=A.length;

    while( l<=r){

        int mid = (l+r)/2;

        if(mid-1 >=0 &&  A[mid] != A[mid-1] && mid+1<n && A[mid] != A[mid+1]){
            return A[mid];
        }
        
        int startIdx = mid;

        if( mid-1 >= 0 && A[mid]  == A[mid-1]){
            startIdx = mid-1;
        }

        if( startIdx % 2 ==0){
            l=mid+1;
        }else{
            r=mid-1;
        }
    }

    if( A[0] != A[1]){
        return A[0];
    }else{

    return A[n-1];
    }
    }
}


Q - Find a peak element

Given an array of integers A, find and return the peak element in it.
An array element is considered a peak if it is not smaller than its neighbors. For corner elements, we need to consider only one neighbor.

NOTE:

It is guaranteed that the array contains only a single peak element.
Users are expected to solve this in O(log(N)) time. The array may contain duplicate elements.


Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 109

Example Input

Input 1:

A = [1, 2, 3, 4, 5]
Input 2:

A = [5, 17, 100, 11]




Example Output

Output 1:


 5
Output 2:

 100


Example Explanation

Explanation 1:

 5 is the peak.
Explanation 2:

 100 is the peak.


 Approach - 


 Problem Setup (restating)

We are guaranteed exactly one peak exists.

A peak = element ‚â• neighbors.

Corners only need one neighbor check.

Duplicates allowed, but not "too many" (explained later).

You must find the index of the peak in O(log N).

üîπ Hints Breakdown
1. ‚ÄúArray can be one of 3 types‚Äù

This is the structural guarantee. If only one peak exists, the array cannot be random; it must look like one of these:

Strictly Decreasing
[9, 7, 5, 3] ‚Üí Peak is at index 0.

Strictly Increasing
[1, 4, 6, 9] ‚Üí Peak is at index n-1.

Increasing then Decreasing (mountain shape)
[1, 3, 8, 12, 4, 2] ‚Üí Peak is at 12 (the top of the mountain).

This restriction is why binary search works:

If you look at the middle element, you can decide which side to go.

The "mountain" guarantees you don‚Äôt skip the unique peak.

2. ‚ÄúAt most one pair of equal adjacent elements‚Äù

Why this rule? Because duplicates can create multiple peaks if unrestricted.

Example (invalid case):
[5, 5, 5] ‚Üí all three are peaks, violates uniqueness.

So rules:

No 3 consecutive equal elements.

At most one pair equal: [1, 3, 5, 5, 2] ‚Üí Peak is one of the 5s.

This ensures uniqueness of peak is still valid even with duplicates.

3. ‚ÄúIf duplicates exist, one must be the peak‚Äù

If A[i] == A[i+1], then one of them must satisfy the "not smaller than both neighbors" condition.

Example:
[1, 3, 5, 5, 2]

Both 5s are ‚â• neighbors, so either index is valid as the peak.

This rule simplifies the problem so binary search doesn‚Äôt break on equals.

4. ‚ÄúCan you apply binary search for the index?‚Äù

Yes. Here‚Äôs the trick binary search uses:

At index mid:

If A[mid] > A[mid+1], it means we are in the decreasing slope of the mountain ‚Üí the peak is at mid or to the left, so move r = mid.

Else (A[mid] <= A[mid+1]), we are in the increasing slope ‚Üí the peak is to the right, so move l = mid + 1.

This works because the array is shaped like a mountain (one peak) and binary search ‚Äúwalks‚Äù towards it.

Code - 

  public int solve(int[] A) {

        int l=0, r=A.length-1;

        while( l < r){

            int mid = (l+r)/2;

            if( mid+1 < A.length && A[mid] > A[mid+1]  ){
                 r=mid;
            }else{
                l=mid+1;
            }
        }

        return A[l];
       
    }


Q - Minimum Difference


You are given a 2-D matrix C of size A √ó B.
You need to build a new 1-D array of size A by taking one element from each row of the 2-D matrix in such a way that the cost of the newly built array is minimized.

The cost of an array is the minimum possible value of the absolute difference between any two adjacent elements of the array.

So if the newly built array is X, the element picked from row 1 will become X[1], element picked from row 2 will become X[2], and so on.

Determine the minimum cost of the newly built array.



Problem Constraints

2 <= A <= 1000
2 <= B <= 1000
1 <= C[i][j] <= 106

Example Input

Input 1:

 A = 2
 B = 2
 C = [ [8, 4]
      [6, 8] ]
Input 2:

 A = 3
 B = 2
 C = [ [7, 3]
       [2, 1]
       [4, 9] ]


Example Output

Output 1:

 0
Output 2:

 1


Example Explanation

Explanation 1:

 Newly build array : [8, 8]. The minimum cost will be 0 since the absolute difference will be 0(8-8).
Explanation 2:

 Newly build array : [3, 2, 4]. The minimum cost will be 1 since the minimum absolute difference will be 1(3 - 2).

 Approach -
 
Sort every row.
For each element in a row, binary search in the next row to find the nearest greater/equal (a) and nearest smaller (b).
Track the global minimum difference across all such pairs.
That value is the minimum cost of the built array.


Why Sorting Helps

If each row is sorted:

We can efficiently find candidates in the next row that are ‚Äúclosest‚Äù to the current element.

This allows us to check the best possible adjacent pairings.

For any chosen C[i][j] (from row i), the next element in row i+1 that minimizes the difference must be either:

The smallest element ‚â• C[i][j] (let‚Äôs call it a)

The largest element < C[i][j] (let‚Äôs call it b)

Why only these two?

Because in a sorted list, the closest number to C[i][j] is either its immediate predecessor or immediate successor (found via binary search / lower_bound).

No need to check all elements of row i+1.

 Updating the Answer

For each adjacent row pair (i, i+1):

For each element C[i][j]:

Find a = lower_bound(C[i+1], C[i][j])

Find b = element just before a

Update:

ans = min(ans, min(|a - C[i][j]|, |C[i][j] - b|))


Thus, ans will always store the smallest gap possible between some consecutive row elements, across the entire matrix.

This works because the global cost is the minimum of all consecutive row differences, and we are explicitly tracking that as we scan.

Intuition with an Example

Suppose:

Row 1: [1, 5, 9]
Row 2: [4, 8, 15]
Row 3: [2, 6, 20]


Pick 5 from Row 1.

In Row 2: lower_bound(5) = 8, predecessor = 4.

Closest = min(|8-5|, |5-4|) = min(3,1) = 1.

Similarly check for all.

At the end, ans will be the smallest adjacent-row gap you cannot avoid, i.e. the minimum cost.

Dry run - 

Row1: [1, 5, 9]
Row2: [4, 8, 15]
Row3: [2, 6, 20]
(Each row is already sorted. If not, we‚Äôd sort first.)

Initialize: ans = +‚àû

Between Row1 and Row2
We scan each element x in Row1 and binary-search Row2 for the closest neighbors.

x = 1
lower_bound(1) in Row2 ‚Üí 4 (no predecessor)

Candidates: only 4

Gaps: |4 - 1| = 3

ans = min(+‚àû, 3) = 3

x = 5
lower_bound(5) in Row2 ‚Üí 8, predecessor ‚Üí 4

Gaps: |8 - 5| = 3, |5 - 4| = 1

Best for this x: 1

ans = min(3, 1) = 1

x = 9
lower_bound(9) in Row2 ‚Üí 15, predecessor ‚Üí 8

Gaps: |15 - 9| = 6, |9 - 8| = 1

Best for this x: 1

ans = min(1, 1) = 1

(So far, the tightest unavoidable gap across rows 1‚Üí2 is 1.)

Between Row2 and Row3
Do the same from Row2 into Row3.

y = 4
lower_bound(4) in Row3 ‚Üí 6, predecessor ‚Üí 2

Gaps: |6 - 4| = 2, |4 - 2| = 2

Best: 2

ans = min(1, 2) = 1

y = 8
lower_bound(8) in Row3 ‚Üí 20, predecessor ‚Üí 6

Gaps: |20 - 8| = 12, |8 - 6| = 2

Best: 2

ans = min(1, 2) = 1

y = 15
lower_bound(15) in Row3 ‚Üí 20, predecessor ‚Üí 6

Gaps: |20 - 15| = 5, |15 - 6| = 9

Best: 5

ans = min(1, 5) = 1



Lower bound method dry run  - 

Example 1
arr = [2, 6, 20]
key = 5


lo = 0, hi = 3

mid = 1 ‚Üí arr[1] = 6 ‚â• 5 ‚Üí hi = 1

Now lo = 0, hi = 1

mid = 0 ‚Üí arr[0] = 2 < 5 ‚Üí lo = 1

Now lo = 1, hi = 1 ‚Üí loop ends.

Return 1.

üëâ lowerBound([2,6,20], 5) = 1
(because arr[1] = 6 is the first element ‚â• 5)

Example 2
arr = [2, 6, 20]
key = 6


lo = 0, hi = 3

mid = 1 ‚Üí arr[1] = 6 ‚â• 6 ‚Üí hi = 1

Now lo = 0, hi = 1

mid = 0 ‚Üí arr[0] = 2 < 6 ‚Üí lo = 1

Now lo = 1, hi = 1 ‚Üí loop ends.

Return 1.

üëâ lowerBound([2,6,20], 6) = 1
(because arr[1] = 6 is the first element ‚â• 6)

Example 3
arr = [2, 6, 20]
key = 21


lo = 0, hi = 3

mid = 1 ‚Üí arr[1] = 6 < 21 ‚Üí lo = 2

lo = 2, hi = 3

mid = 2 ‚Üí arr[2] = 20 < 21 ‚Üí lo = 3

Now lo = 3, hi = 3 ‚Üí loop ends.

Return 3.

üëâ lowerBound([2,6,20], 21) = 3
(no element ‚â• 21, so returns arr.length)

Example 4
arr = [2, 6, 20]
key = 1


lo = 0, hi = 3

mid = 1 ‚Üí arr[1] = 6 ‚â• 1 ‚Üí hi = 1

lo = 0, hi = 1

mid = 0 ‚Üí arr[0] = 2 ‚â• 1 ‚Üí hi = 0

lo = 0, hi = 0 ‚Üí loop ends.

Return 0.

üëâ lowerBound([2,6,20], 1) = 0
(because arr[0] = 2 is the first element ‚â• 1)

Pattern - 

If key is smaller than all ‚Üí return 0.

If key is inside the range ‚Üí return index of first ‚â• key.

If key is bigger than all ‚Üí return arr.length.



idx < B ‚Üí candidate from the right side (greater or equal).

idx > 0 ‚Üí candidate from the left side (smaller).


Code - 


public static int minCost(int[][] C) {
        int A = C.length;      // number of rows
        int B = C[0].length;   // number of columns

        // Step 1: sort each row
        for (int i = 0; i < A; i++) {
            Arrays.sort(C[i]);
        }

        int ans = Integer.MAX_VALUE;

        // Step 2: check differences between consecutive rows
        for (int i = 0; i < A - 1; i++) {
            for (int j = 0; j < B; j++) {
                int val = C[i][j];
                // find lower_bound in the next row
                int idx = lowerBound(C[i + 1], val);


              //  idx < B ‚Üí candidate from the right side (greater or equal).

                // idx > 0 ‚Üí candidate from the left side (smaller).

                // Case 1: idx within bounds -> element >= val
                if (idx < B) {
                    ans = Math.min(ans, Math.abs(C[i + 1][idx] - val));
                }

                // Case 2: predecessor exists
                if (idx > 0) {
                    ans = Math.min(ans, Math.abs(val - C[i + 1][idx - 1]));
                }
            }
        }

        return ans;
    }

    // Custom lower_bound: first index where arr[idx] >= key
    private static int lowerBound(int[] arr, int key) {
        int lo = 0, hi = arr.length;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (arr[mid] < key) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return lo;
    }


Q - Rotated Sorted Array Search

Given a sorted array of integers A of size N and an integer B, 
where array A is rotated at some pivot unknown beforehand.

For example, the array [0, 1, 2, 4, 5, 6, 7] might become [4, 5, 6, 7, 0, 1, 2].

Your task is to search for the target value B in the array. If found, return its index; otherwise, return -1.

You can assume that no duplicates exist in the array.

NOTE: You are expected to solve this problem with a time complexity of O(log(N)).


Problem Constraints

1 <= N <= 1000000
1 <= A[i] <= 109
All elements in A are Distinct.


Example Input

Input 1:

A = [4, 5, 6, 7, 0, 1, 2, 3]
B = 4 
Input 2:

A : [ 9, 10, 3, 5, 6, 8 ]
B : 5


Example Output

Output 1:

 0 
Output 2:

 3

 Approach - 

 Find the pivot (the smallest element in the rotated array).

Why? Because the array is really two sorted subarrays:
[pivot ‚Ä¶ end] and [start ‚Ä¶ pivot-1].

Once you know the pivot:

If B lies between arr[pivot] and arr[end], search in the right half.

Otherwise, search in the left half.

Both halves are individually sorted, so we can do normal binary search there.

How do we find the pivot efficiently?

We use binary search logic again.
We compare the middle element (arr[mid]) with the last element (arr[end]):

Case 1: arr[mid] > arr[end]

Since arr[mid] > arr[end], the rotation point (min element) must be to the right of mid.
So pivot lies in (mid, end]

Case 2: arr[mid] < arr[end]

Since arr[mid] < arr[end], the rotation point is on the left side (including mid).
So pivot lies in [start, mid]

Case 3: (only if duplicates exist)

If arr[mid] == arr[end], then you can‚Äôt decide which side the pivot lies on (both look possible).
In that case, you‚Äôd fall back to linear search.

But in our problem statement, no duplicates exist, so we can ignore this case.

After pivot is found

Suppose pivot = index of minimum element.

If B is between arr[pivot] and arr[end], do binary search in [pivot ‚Ä¶ end].

Else, do binary search in [start ‚Ä¶ pivot-1].


Code  -

    public int search(final int[] A, int B) {

        int lo=0, hi=A.length-1;


        while( lo <= hi){

            int mid  = (lo+hi)/2;

            if(A[mid] == B){
                return mid;
            }else if( A[mid] < A[hi]){
                
                if(A[mid] < B && A[hi] >= B){

                lo = mid+1;
                }else{
                    hi = mid-1;
                }
            }else {

                if(A[lo] <= B && A[mid] > B){
                hi = mid-1;
                }else{
                    lo= mid+1;
                }
            }
        }

        return -1;
    }


Q - Matrix Median

Given a matrix of integers A of size N x M in which each row is sorted.


Find and return the overall median of matrix A.

NOTE: No extra memory is allowed.

NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.



Problem Constraints

1 <= N, M <= 10^5

1 <= N*M <= 10^6

1 <= A[i] <= 10^9

N*M is odd

Example Input

Input 1:

A = [   [1, 3, 5],
        [2, 6, 9],
        [3, 6, 9]   ] 
Input 2:

A = [   [5, 17, 100]    ]


Example Output

Output 1:

 5 
Output 2:

 17


Example Explanation

Explanation 1:

A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
Median is 5. So, we return 5. 
Explanation 2:

Median is 17.


Appraoch - 

Determine search boundaries

min = smallest element across all rows (first element of each row).

max = largest element across all rows (last element of each row).

Binary search loop

While low < high:

Take mid = (low + high) / 2.

Count elements ‚â§ mid.

If count < median position, move low up.

Else, move high down.

Final answer is low (or high).

Counting step

For each row (since it‚Äôs sorted), quickly count how many numbers are ‚â§ mid.

Use binary search per row for efficiency.

Sum counts from all rows.


Code - 


public class Solution {
    public int findMedian(int[][] A) {

        int n=A.length;
        int m= A[0].length;

        int min =  Integer.MAX_VALUE;
        int max =Integer.MIN_VALUE;

        for(int i=0; i <n; i++){
                min = Math.min(min, A[i][0]);
                max = Math.max(max, A[i][m-1]);
            
        }


        long low=min, high=max;
        long totalElements = n*m+1;

        while( low < high){

            long mid = (low+high) /2;

            int cnt = elementsLessThan(A, mid);

            if(cnt < (totalElements/2)){
                low = mid+1;
            }else{
                high = mid;
            }
        }

        return (int)low;

    }

    public int elementsLessThan(int[][] arr, long val){

        int n =arr.length;
        int a =arr[0].length;

        int ans=0;
        
        for(int i=0; i<n; i++){

            int lo=0, hi=a-1;

            while(lo <= hi){

                int mid = (lo+hi)/2;

                if(arr[i][mid] <= val ){

                    lo=mid+1;
                }else{
                    hi = mid-1;
                }
            }

            ans += lo;
        }

        return ans;

    }
}

// Try to implement this approach. Start by writing a function to count elements <= a given number in the entire matrix. 



Q - ADD OR NOT

Given an array of integers A of size N and an integer B.

In a single operation, any one element of the array can be increased by 1. You are allowed to do at most B such operations.

Find the number with the maximum number of occurrences and return an array C of size 2, where C[0] is the number of occurrences, and C[1] is the number with maximum occurrence.
If there are several such numbers, your task is to find the minimum one.



Problem Constraints

1 <= N <= 105

-109 <= A[i] <= 109

0 <= B <= 109



Input Format

The first argument given is the integer array A.
The second argument given is the integer B.



Output Format

Return an array C of size 2, where C[0] is number of occurence and C[1] is the number with maximum occurence.



Example Input

Input 1:

 A = [3, 1, 2, 2, 1]
 B = 3
Input 2:

 A = [5, 5, 5]
 B = 3


Example Output

Output 1:

 [4, 2]
Output 2:

 [3, 5]


Example Explanation

Explanation 1:

 Apply operations on A[2] and A[4]
 A = [3, 2, 2, 2, 2]
 Maximum occurence =  4
 Minimum value of element with maximum occurence = 2
Explanation 2:

 A = [5, 5, 5]
 Maximum occurence =  3
 Minimum value of element with maximum occurence = 5


 Appraoch - 

 Intuition

To maximize frequency of some number X, you should take smaller numbers and increase them up to X (never decrease larger numbers).

To save operations, you always want to increase numbers that are closest to X, not far away.

That‚Äôs why sorting is important: once sorted, the elements before X are candidates to be raised to X.

3. Brute Force Idea

For each element A[i]:

Look backward (j = i, i-1, ...) and try to increase numbers up to A[i] while budget allows.

Count how many numbers can become equal to A[i].

Update max answer.

This works but is O(n¬≤) in the worst case (too slow for n = 10^5).

4. Optimized Idea (Using Prefix Sums + Binary Search)

We need faster checking:

Step 1. Sort Array

After sorting, we only ever increase smaller values to match a larger value.

Example: A = [1, 2, 2, 3], B = 3
If we want frequency at 3, we‚Äôll consider: can we raise [1,2,2] to 3?

Step 2. Use Prefix Sums for Range Sums

Define prefix[i] = sum of first i elements.
So, prefix[k] = A[0] + A[1] + ... + A[k-1].

This lets us calculate sums of any subarray quickly:

sum(l, r) = prefix[r+1] - prefix[l]

Step 3. Checking Feasibility

Suppose we fix A[i] as the target number.
We want to check: how many previous elements can we raise to become A[i]?

Take cnt elements ending at i (so subarray [i-cnt+1, ..., i]).

To make them all equal to A[i], cost is:

(A[i] * cnt) - (sum of those cnt elements)
= A[i]*cnt - (prefix[i+1] - prefix[i-cnt+1])


If this cost ‚â§ B, then it‚Äôs possible.

Step 4. Binary Search

Now instead of linearly trying all possible cnt values, we use binary search:

Low = 1, High = i+1 (since max cnt is i+1 elements).

For each mid = (low+high)/2:

Compute cost.

If cost ‚â§ B ‚Üí feasible ‚Üí try more elements (move right).

Else ‚Üí reduce cnt (move left).

Thus, for each A[i], we find the maximum cnt that can be made equal to A[i].

Step 5. Track Best Answer

Keep track of:

Largest frequency found (ans[0]).

The corresponding number (ans[1]).
If same frequency occurs, choose smaller number (but since array is sorted, this naturally works).

5. Complexity

Sorting: O(n log n)

For each i, binary search up to O(log n) with prefix sums O(1).

Total: O(n log n)
This fits within constraints (n ‚â§ 10^5).

6. Walking Through the Code
Arrays.sort(A);   // step 1: sort
// prefix[i+1] = sum of first (i+1) elements
for (int i = 0; i < n; i++) {
    prefix[i + 1] = A[i] + prefix[i];
}


Now prefix helps get sums quickly.

Loop over each target number:

for (int i = 0; i < n; i++) {
    int lo = 1, hi = i + 1;
    int mx = 0;
    // binary search maximum cnt
    while (lo <= hi) {
        int cnt = (lo + hi) / 2;
        long cost = (long) A[i]*cnt - (prefix[i+1] - prefix[i-cnt+1]);
        if (cost <= B) {
            mx = cnt;        // feasible
            lo = cnt + 1;    // try bigger cnt
        } else {
            hi = cnt - 1;    // too costly, try smaller cnt
        }
    }
    // update answer
    if (ans[0] < mx) {
        ans[0] = mx;
        ans[1] = A[i];
    }
}


For each i, mx tells us the largest frequency achievable if A[i] is the target.

Update global best.

Return [frequency, number].

7. Example Walkthrough

Input:
A = [3,1,2,2,1], B = 3

Sorted: A = [1,1,2,2,3]
Prefix: [0,1,2,4,6,9]

Check i=4, A[i]=3:
Binary search for max cnt:

cnt=3: cost = 3*3 - (prefix[5]-prefix[2]) = 9 - (9-2) = 2 (‚â§3 ‚úÖ)

cnt=4: cost = 3*4 - (prefix[5]-prefix[1]) = 12 - (9-1) = 4 (>3 ‚ùå)
So max cnt=3 for 3.

Check i=3, A[i]=2:

cnt=4: cost = 2*4 - (prefix[4]-prefix[0]) = 8 - 6 = 2 (‚â§3 ‚úÖ)
So max cnt=4 for 2.

Answer ‚Üí [4, 2].


Code  - 

public class Solution {

    public int[] solve(int[] A, int B) {
            
           // To do the prefix sum
      long prefix[] = new long[A.length + 1];
      Arrays.sort(A);
      int n = A.length;
      // Make prefix array
      for (int i = 0; i < n; i++) {
         prefix[i + 1] += A[i] + prefix[i];
      }
      int ans[] = new int[2];
      ans[0] = -1;
      ans[1] = -1;
      for (int i = 0; i < n; i++) {
         int lo = 1, hi = i + 1;
         int mx = 0;
         // Binary search to find the value of cnt for each i
         while (lo <= hi) {
            int cnt = (lo + hi) / 2;
            if ((long) A[i] * cnt - (prefix[i + 1] - prefix[i - cnt + 1]) <= B) {
               mx = cnt;
               lo = cnt + 1;
            } else {
               hi = cnt - 1;
            }
         }
         // Update ans
         if (ans[0] < mx) {
            ans[0] = mx;
            ans[1] = A[i];
         }
      }
      return ans;

    }
    public int[] solveBF(int[] A, int B) {

     

Arrays.sort(A);

int n= A.length;

int[] ans = new int[2];

ans[0]=-1;
ans[1]=-1;

for( int i =0; i < n; i++){

int count=0;
int operations = B;

for( int j=i; j>=0; j--){

if( A[i] - A[j] <= operations ){

operations -= A[i]-A[j];
count++;
}else {
break;}

if( ans[0] < count){
ans[0] = count;
ans[1] = A[i];
}
}

}
return ans;

}

    public static int minIdx(int[] A, int target){

        int n=A.length;
        int lo=0, hi=n-1;
        int idx=-1;

        while( lo <= hi){
            int mid = (lo + hi) /2;

            if( A[mid] <= target){
                lo = mid+1;
                idx = mid;
            }else{
                hi=mid-1;
            }
        }

        return idx;
    }
}



