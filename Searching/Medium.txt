Q - Matrix Search

Given a matrix of integers A of size N x M and an integer B. Write an efficient algorithm that searches for integer B in matrix A.

This matrix A has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than or equal to the last integer of the previous row.
Return 1 if B is present in A, else return 0.

NOTE: Rows are numbered from top to bottom, and columns are from left to right.



Problem Constraints

1 <= N, M <= 1000
1 <= A[i][j], B <= 106

Example Input

Input 1:

A = [ 
      [1,   3,  5,  7]
      [10, 11, 16, 20]
      [23, 30, 34, 50]  
    ]
B = 3
Input 2:

A = [   
      [5, 17, 100, 111]
      [119, 120, 127, 131]    
    ]
B = 3


Example Output

Output 1:

1
Output 2:

0

Code - 

public class Solution {
    public int searchMatrix(int[][] A, int B) {

        int rows=A.length, cols=A[0].length;

        int row=0;
        int col=cols-1;

        while(row<rows && col>=0){

            if(A[row][col] ==B){
                return 1;
            }else if( A[row][col] > B){
                col--;
            }else{
                row++;
            }
        }

        return 0;


    }
}

Q - Search for a Range

Given a sorted array of integers A (0-indexed) of size N, find the left most and the right most index of a given integer B in the array A.

Return an array of size 2, such that 
          First element = Left most index of B in A
          Second element = Right most index of B in A.
If B is not found in A, return [-1, -1].

Note : Note: The time complexity of your algorithm must be O(log n)..


Problem Constraints

1 <= N <= 106
1 <= A[i], B <= 109

Example Input

Input 1:

 A = [5, 7, 7, 8, 8, 10]
 B = 8
Input 2:

 A = [5, 17, 100, 111]
 B = 3


Example Output

Output 1:

 [3, 4]
Output 2:

 [-1, -1]


 Approach - Find out the left most index of B and then again find out 
 right most index of B using binary search and at the end return both indexes.

 Code - 

 public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int[] searchRange(final int[] A, int B) {

        int l=0, r=A.length-1;

        int start=-1;
        int end=-1;

        while( l <=r){

            int mid = (l+r)/2;

            if(A[mid] == B){
                
                start=mid;
                r = mid-1;
            }else if( A[mid] > B){
                r = mid-1;
            }else{
                l=mid+1;
            }
        }

        l=0;
        r=A.length-1;

        while( l<=r){
            int mid = (l+r)/2;

            if( A[mid] == B){
                l=mid+1;
                end=mid;
            }else if( A[mid] > B ){
                r=mid-1;
            }else{
                l = mid+1;
            }
        }

        int[] ans = new int[2];

        ans[0] = start;
        ans[1] = end;

        return ans;
    }
}

Q  -  Single Element in Sorted Array

Given a sorted array of integers A where every element appears twice except for one element which appears once, find and return this single element that appears only once.

Elements which are appearing twice are adjacent to each other.

NOTE: Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 10^9

Example Input

Input 1:

A = [1, 1, 7]
Input 2:

A = [2, 3, 3]


Example Output

Output 1:

 7
Output 2:

 2


 Approach - 
 
 observation - 

First occurence of the element is present at even index before unique element.

First occurence of the element is present at odd index after unique element.


Code - 

public class Solution {
    public int solve(int[] A) {
    

    if(A.length ==1){
        return A[0];
    }
    
    int l=0, r=A.length-1;
    int n=A.length;

    while( l<=r){

        int mid = (l+r)/2;

        if(mid-1 >=0 &&  A[mid] != A[mid-1] && mid+1<n && A[mid] != A[mid+1]){
            return A[mid];
        }
        
        int startIdx = mid;

        if( mid-1 >= 0 && A[mid]  == A[mid-1]){
            startIdx = mid-1;
        }

        if( startIdx % 2 ==0){
            l=mid+1;
        }else{
            r=mid-1;
        }
    }

    if( A[0] != A[1]){
        return A[0];
    }else{

    return A[n-1];
    }
    }
}


Q - Find a peak element

Given an array of integers A, find and return the peak element in it.
An array element is considered a peak if it is not smaller than its neighbors. For corner elements, we need to consider only one neighbor.

NOTE:

It is guaranteed that the array contains only a single peak element.
Users are expected to solve this in O(log(N)) time. The array may contain duplicate elements.


Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 109

Example Input

Input 1:

A = [1, 2, 3, 4, 5]
Input 2:

A = [5, 17, 100, 11]




Example Output

Output 1:


 5
Output 2:

 100


Example Explanation

Explanation 1:

 5 is the peak.
Explanation 2:

 100 is the peak.


 Approach - 


 Problem Setup (restating)

We are guaranteed exactly one peak exists.

A peak = element â‰¥ neighbors.

Corners only need one neighbor check.

Duplicates allowed, but not "too many" (explained later).

You must find the index of the peak in O(log N).

ðŸ”¹ Hints Breakdown
1. â€œArray can be one of 3 typesâ€

This is the structural guarantee. If only one peak exists, the array cannot be random; it must look like one of these:

Strictly Decreasing
[9, 7, 5, 3] â†’ Peak is at index 0.

Strictly Increasing
[1, 4, 6, 9] â†’ Peak is at index n-1.

Increasing then Decreasing (mountain shape)
[1, 3, 8, 12, 4, 2] â†’ Peak is at 12 (the top of the mountain).

This restriction is why binary search works:

If you look at the middle element, you can decide which side to go.

The "mountain" guarantees you donâ€™t skip the unique peak.

2. â€œAt most one pair of equal adjacent elementsâ€

Why this rule? Because duplicates can create multiple peaks if unrestricted.

Example (invalid case):
[5, 5, 5] â†’ all three are peaks, violates uniqueness.

So rules:

No 3 consecutive equal elements.

At most one pair equal: [1, 3, 5, 5, 2] â†’ Peak is one of the 5s.

This ensures uniqueness of peak is still valid even with duplicates.

3. â€œIf duplicates exist, one must be the peakâ€

If A[i] == A[i+1], then one of them must satisfy the "not smaller than both neighbors" condition.

Example:
[1, 3, 5, 5, 2]

Both 5s are â‰¥ neighbors, so either index is valid as the peak.

This rule simplifies the problem so binary search doesnâ€™t break on equals.

4. â€œCan you apply binary search for the index?â€

Yes. Hereâ€™s the trick binary search uses:

At index mid:

If A[mid] > A[mid+1], it means we are in the decreasing slope of the mountain â†’ the peak is at mid or to the left, so move r = mid.

Else (A[mid] <= A[mid+1]), we are in the increasing slope â†’ the peak is to the right, so move l = mid + 1.

This works because the array is shaped like a mountain (one peak) and binary search â€œwalksâ€ towards it.

Code - 

  public int solve(int[] A) {

        int l=0, r=A.length-1;

        while( l < r){

            int mid = (l+r)/2;

            if( mid+1 < A.length && A[mid] > A[mid+1]  ){
                 r=mid;
            }else{
                l=mid+1;
            }
        }

        return A[l];
       
    }


Q - Minimum Difference


You are given a 2-D matrix C of size A Ã— B.
You need to build a new 1-D array of size A by taking one element from each row of the 2-D matrix in such a way that the cost of the newly built array is minimized.

The cost of an array is the minimum possible value of the absolute difference between any two adjacent elements of the array.

So if the newly built array is X, the element picked from row 1 will become X[1], element picked from row 2 will become X[2], and so on.

Determine the minimum cost of the newly built array.



Problem Constraints

2 <= A <= 1000
2 <= B <= 1000
1 <= C[i][j] <= 106

Example Input

Input 1:

 A = 2
 B = 2
 C = [ [8, 4]
      [6, 8] ]
Input 2:

 A = 3
 B = 2
 C = [ [7, 3]
       [2, 1]
       [4, 9] ]


Example Output

Output 1:

 0
Output 2:

 1


Example Explanation

Explanation 1:

 Newly build array : [8, 8]. The minimum cost will be 0 since the absolute difference will be 0(8-8).
Explanation 2:

 Newly build array : [3, 2, 4]. The minimum cost will be 1 since the minimum absolute difference will be 1(3 - 2).

 Approach -
 
Sort every row.
For each element in a row, binary search in the next row to find the nearest greater/equal (a) and nearest smaller (b).
Track the global minimum difference across all such pairs.
That value is the minimum cost of the built array.


Why Sorting Helps

If each row is sorted:

We can efficiently find candidates in the next row that are â€œclosestâ€ to the current element.

This allows us to check the best possible adjacent pairings.

For any chosen C[i][j] (from row i), the next element in row i+1 that minimizes the difference must be either:

The smallest element â‰¥ C[i][j] (letâ€™s call it a)

The largest element < C[i][j] (letâ€™s call it b)

Why only these two?

Because in a sorted list, the closest number to C[i][j] is either its immediate predecessor or immediate successor (found via binary search / lower_bound).

No need to check all elements of row i+1.

 Updating the Answer

For each adjacent row pair (i, i+1):

For each element C[i][j]:

Find a = lower_bound(C[i+1], C[i][j])

Find b = element just before a

Update:

ans = min(ans, min(|a - C[i][j]|, |C[i][j] - b|))


Thus, ans will always store the smallest gap possible between some consecutive row elements, across the entire matrix.

This works because the global cost is the minimum of all consecutive row differences, and we are explicitly tracking that as we scan.

Intuition with an Example

Suppose:

Row 1: [1, 5, 9]
Row 2: [4, 8, 15]
Row 3: [2, 6, 20]


Pick 5 from Row 1.

In Row 2: lower_bound(5) = 8, predecessor = 4.

Closest = min(|8-5|, |5-4|) = min(3,1) = 1.

Similarly check for all.

At the end, ans will be the smallest adjacent-row gap you cannot avoid, i.e. the minimum cost.

Dry run - 

Row1: [1, 5, 9]
Row2: [4, 8, 15]
Row3: [2, 6, 20]
(Each row is already sorted. If not, weâ€™d sort first.)

Initialize: ans = +âˆž

Between Row1 and Row2
We scan each element x in Row1 and binary-search Row2 for the closest neighbors.

x = 1
lower_bound(1) in Row2 â†’ 4 (no predecessor)

Candidates: only 4

Gaps: |4 - 1| = 3

ans = min(+âˆž, 3) = 3

x = 5
lower_bound(5) in Row2 â†’ 8, predecessor â†’ 4

Gaps: |8 - 5| = 3, |5 - 4| = 1

Best for this x: 1

ans = min(3, 1) = 1

x = 9
lower_bound(9) in Row2 â†’ 15, predecessor â†’ 8

Gaps: |15 - 9| = 6, |9 - 8| = 1

Best for this x: 1

ans = min(1, 1) = 1

(So far, the tightest unavoidable gap across rows 1â†’2 is 1.)

Between Row2 and Row3
Do the same from Row2 into Row3.

y = 4
lower_bound(4) in Row3 â†’ 6, predecessor â†’ 2

Gaps: |6 - 4| = 2, |4 - 2| = 2

Best: 2

ans = min(1, 2) = 1

y = 8
lower_bound(8) in Row3 â†’ 20, predecessor â†’ 6

Gaps: |20 - 8| = 12, |8 - 6| = 2

Best: 2

ans = min(1, 2) = 1

y = 15
lower_bound(15) in Row3 â†’ 20, predecessor â†’ 6

Gaps: |20 - 15| = 5, |15 - 6| = 9

Best: 5

ans = min(1, 5) = 1



Lower bound method dry run  - 

Example 1
arr = [2, 6, 20]
key = 5


lo = 0, hi = 3

mid = 1 â†’ arr[1] = 6 â‰¥ 5 â†’ hi = 1

Now lo = 0, hi = 1

mid = 0 â†’ arr[0] = 2 < 5 â†’ lo = 1

Now lo = 1, hi = 1 â†’ loop ends.

Return 1.

ðŸ‘‰ lowerBound([2,6,20], 5) = 1
(because arr[1] = 6 is the first element â‰¥ 5)

Example 2
arr = [2, 6, 20]
key = 6


lo = 0, hi = 3

mid = 1 â†’ arr[1] = 6 â‰¥ 6 â†’ hi = 1

Now lo = 0, hi = 1

mid = 0 â†’ arr[0] = 2 < 6 â†’ lo = 1

Now lo = 1, hi = 1 â†’ loop ends.

Return 1.

ðŸ‘‰ lowerBound([2,6,20], 6) = 1
(because arr[1] = 6 is the first element â‰¥ 6)

Example 3
arr = [2, 6, 20]
key = 21


lo = 0, hi = 3

mid = 1 â†’ arr[1] = 6 < 21 â†’ lo = 2

lo = 2, hi = 3

mid = 2 â†’ arr[2] = 20 < 21 â†’ lo = 3

Now lo = 3, hi = 3 â†’ loop ends.

Return 3.

ðŸ‘‰ lowerBound([2,6,20], 21) = 3
(no element â‰¥ 21, so returns arr.length)

Example 4
arr = [2, 6, 20]
key = 1


lo = 0, hi = 3

mid = 1 â†’ arr[1] = 6 â‰¥ 1 â†’ hi = 1

lo = 0, hi = 1

mid = 0 â†’ arr[0] = 2 â‰¥ 1 â†’ hi = 0

lo = 0, hi = 0 â†’ loop ends.

Return 0.

ðŸ‘‰ lowerBound([2,6,20], 1) = 0
(because arr[0] = 2 is the first element â‰¥ 1)

Pattern - 

If key is smaller than all â†’ return 0.

If key is inside the range â†’ return index of first â‰¥ key.

If key is bigger than all â†’ return arr.length.



idx < B â†’ candidate from the right side (greater or equal).

idx > 0 â†’ candidate from the left side (smaller).


Code - 


public static int minCost(int[][] C) {
        int A = C.length;      // number of rows
        int B = C[0].length;   // number of columns

        // Step 1: sort each row
        for (int i = 0; i < A; i++) {
            Arrays.sort(C[i]);
        }

        int ans = Integer.MAX_VALUE;

        // Step 2: check differences between consecutive rows
        for (int i = 0; i < A - 1; i++) {
            for (int j = 0; j < B; j++) {
                int val = C[i][j];
                // find lower_bound in the next row
                int idx = lowerBound(C[i + 1], val);


              //  idx < B â†’ candidate from the right side (greater or equal).

                // idx > 0 â†’ candidate from the left side (smaller).

                // Case 1: idx within bounds -> element >= val
                if (idx < B) {
                    ans = Math.min(ans, Math.abs(C[i + 1][idx] - val));
                }

                // Case 2: predecessor exists
                if (idx > 0) {
                    ans = Math.min(ans, Math.abs(val - C[i + 1][idx - 1]));
                }
            }
        }

        return ans;
    }

    // Custom lower_bound: first index where arr[idx] >= key
    private static int lowerBound(int[] arr, int key) {
        int lo = 0, hi = arr.length;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (arr[mid] < key) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return lo;
    }


Q - Rotated Sorted Array Search

Given a sorted array of integers A of size N and an integer B, 
where array A is rotated at some pivot unknown beforehand.

For example, the array [0, 1, 2, 4, 5, 6, 7] might become [4, 5, 6, 7, 0, 1, 2].

Your task is to search for the target value B in the array. If found, return its index; otherwise, return -1.

You can assume that no duplicates exist in the array.

NOTE: You are expected to solve this problem with a time complexity of O(log(N)).


Problem Constraints

1 <= N <= 1000000
1 <= A[i] <= 109
All elements in A are Distinct.


Example Input

Input 1:

A = [4, 5, 6, 7, 0, 1, 2, 3]
B = 4 
Input 2:

A : [ 9, 10, 3, 5, 6, 8 ]
B : 5


Example Output

Output 1:

 0 
Output 2:

 3

 Approach - 

 Find the pivot (the smallest element in the rotated array).

Why? Because the array is really two sorted subarrays:
[pivot â€¦ end] and [start â€¦ pivot-1].

Once you know the pivot:

If B lies between arr[pivot] and arr[end], search in the right half.

Otherwise, search in the left half.

Both halves are individually sorted, so we can do normal binary search there.

How do we find the pivot efficiently?

We use binary search logic again.
We compare the middle element (arr[mid]) with the last element (arr[end]):

Case 1: arr[mid] > arr[end]

Since arr[mid] > arr[end], the rotation point (min element) must be to the right of mid.
So pivot lies in (mid, end]

Case 2: arr[mid] < arr[end]

Since arr[mid] < arr[end], the rotation point is on the left side (including mid).
So pivot lies in [start, mid]

Case 3: (only if duplicates exist)

If arr[mid] == arr[end], then you canâ€™t decide which side the pivot lies on (both look possible).
In that case, youâ€™d fall back to linear search.

But in our problem statement, no duplicates exist, so we can ignore this case.

After pivot is found

Suppose pivot = index of minimum element.

If B is between arr[pivot] and arr[end], do binary search in [pivot â€¦ end].

Else, do binary search in [start â€¦ pivot-1].


Code  -

    public int search(final int[] A, int B) {

        int lo=0, hi=A.length-1;


        while( lo <= hi){

            int mid  = (lo+hi)/2;

            if(A[mid] == B){
                return mid;
            }else if( A[mid] < A[hi]){
                
                if(A[mid] < B && A[hi] >= B){

                lo = mid+1;
                }else{
                    hi = mid-1;
                }
            }else {

                if(A[lo] <= B && A[mid] > B){
                hi = mid-1;
                }else{
                    lo= mid+1;
                }
            }
        }

        return -1;
    }


Q - Matrix Median

Given a matrix of integers A of size N x M in which each row is sorted.


Find and return the overall median of matrix A.

NOTE: No extra memory is allowed.

NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.



Problem Constraints

1 <= N, M <= 10^5

1 <= N*M <= 10^6

1 <= A[i] <= 10^9

N*M is odd

Example Input

Input 1:

A = [   [1, 3, 5],
        [2, 6, 9],
        [3, 6, 9]   ] 
Input 2:

A = [   [5, 17, 100]    ]


Example Output

Output 1:

 5 
Output 2:

 17


Example Explanation

Explanation 1:

A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
Median is 5. So, we return 5. 
Explanation 2:

Median is 17.


Appraoch - 

Determine search boundaries

min = smallest element across all rows (first element of each row).

max = largest element across all rows (last element of each row).

Binary search loop

While low < high:

Take mid = (low + high) / 2.

Count elements â‰¤ mid.

If count < median position, move low up.

Else, move high down.

Final answer is low (or high).

Counting step

For each row (since itâ€™s sorted), quickly count how many numbers are â‰¤ mid.

Use binary search per row for efficiency.

Sum counts from all rows.


Code - 


public class Solution {
    public int findMedian(int[][] A) {

        int n=A.length;
        int m= A[0].length;

        int min =  Integer.MAX_VALUE;
        int max =Integer.MIN_VALUE;

        for(int i=0; i <n; i++){
                min = Math.min(min, A[i][0]);
                max = Math.max(max, A[i][m-1]);
            
        }


        long low=min, high=max;
        long totalElements = n*m+1;

        while( low < high){

            long mid = (low+high) /2;

            int cnt = elementsLessThan(A, mid);

            if(cnt < (totalElements/2)){
                low = mid+1;
            }else{
                high = mid;
            }
        }

        return (int)low;

    }

    public int elementsLessThan(int[][] arr, long val){

        int n =arr.length;
        int a =arr[0].length;

        int ans=0;
        
        for(int i=0; i<n; i++){

            int lo=0, hi=a-1;

            while(lo <= hi){

                int mid = (lo+hi)/2;

                if(arr[i][mid] <= val ){

                    lo=mid+1;
                }else{
                    hi = mid-1;
                }
            }

            ans += lo;
        }

        return ans;

    }
}

// Try to implement this approach. Start by writing a function to count elements <= a given number in the entire matrix. 

