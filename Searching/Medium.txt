Q - Matrix Search

Given a matrix of integers A of size N x M and an integer B. Write an efficient algorithm that searches for integer B in matrix A.

This matrix A has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than or equal to the last integer of the previous row.
Return 1 if B is present in A, else return 0.

NOTE: Rows are numbered from top to bottom, and columns are from left to right.



Problem Constraints

1 <= N, M <= 1000
1 <= A[i][j], B <= 106

Example Input

Input 1:

A = [ 
      [1,   3,  5,  7]
      [10, 11, 16, 20]
      [23, 30, 34, 50]  
    ]
B = 3
Input 2:

A = [   
      [5, 17, 100, 111]
      [119, 120, 127, 131]    
    ]
B = 3


Example Output

Output 1:

1
Output 2:

0

Code - 

public class Solution {
    public int searchMatrix(int[][] A, int B) {

        int rows=A.length, cols=A[0].length;

        int row=0;
        int col=cols-1;

        while(row<rows && col>=0){

            if(A[row][col] ==B){
                return 1;
            }else if( A[row][col] > B){
                col--;
            }else{
                row++;
            }
        }

        return 0;


    }
}

Q - Search for a Range

Given a sorted array of integers A (0-indexed) of size N, find the left most and the right most index of a given integer B in the array A.

Return an array of size 2, such that 
          First element = Left most index of B in A
          Second element = Right most index of B in A.
If B is not found in A, return [-1, -1].

Note : Note: The time complexity of your algorithm must be O(log n)..


Problem Constraints

1 <= N <= 106
1 <= A[i], B <= 109

Example Input

Input 1:

 A = [5, 7, 7, 8, 8, 10]
 B = 8
Input 2:

 A = [5, 17, 100, 111]
 B = 3


Example Output

Output 1:

 [3, 4]
Output 2:

 [-1, -1]


 Approach - Find out the left most index of B and then again find out 
 right most index of B using binary search and at the end return both indexes.

 Code - 

 public class Solution {
    // DO NOT MODIFY THE ARGUMENTS WITH "final" PREFIX. IT IS READ ONLY
    public int[] searchRange(final int[] A, int B) {

        int l=0, r=A.length-1;

        int start=-1;
        int end=-1;

        while( l <=r){

            int mid = (l+r)/2;

            if(A[mid] == B){
                
                start=mid;
                r = mid-1;
            }else if( A[mid] > B){
                r = mid-1;
            }else{
                l=mid+1;
            }
        }

        l=0;
        r=A.length-1;

        while( l<=r){
            int mid = (l+r)/2;

            if( A[mid] == B){
                l=mid+1;
                end=mid;
            }else if( A[mid] > B ){
                r=mid-1;
            }else{
                l = mid+1;
            }
        }

        int[] ans = new int[2];

        ans[0] = start;
        ans[1] = end;

        return ans;
    }
}

Q  -  Single Element in Sorted Array

Given a sorted array of integers A where every element appears twice except for one element which appears once, find and return this single element that appears only once.

Elements which are appearing twice are adjacent to each other.

NOTE: Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 10^9

Example Input

Input 1:

A = [1, 1, 7]
Input 2:

A = [2, 3, 3]


Example Output

Output 1:

 7
Output 2:

 2


 Approach - 
 
 observation - 

First occurence of the element is present at even index before unique element.

First occurence of the element is present at odd index after unique element.


Code - 

public class Solution {
    public int solve(int[] A) {
    

    if(A.length ==1){
        return A[0];
    }
    
    int l=0, r=A.length-1;
    int n=A.length;

    while( l<=r){

        int mid = (l+r)/2;

        if(mid-1 >=0 &&  A[mid] != A[mid-1] && mid+1<n && A[mid] != A[mid+1]){
            return A[mid];
        }
        
        int startIdx = mid;

        if( mid-1 >= 0 && A[mid]  == A[mid-1]){
            startIdx = mid-1;
        }

        if( startIdx % 2 ==0){
            l=mid+1;
        }else{
            r=mid-1;
        }
    }

    if( A[0] != A[1]){
        return A[0];
    }else{

    return A[n-1];
    }
    }
}


Q - Find a peak element

Given an array of integers A, find and return the peak element in it.
An array element is considered a peak if it is not smaller than its neighbors. For corner elements, we need to consider only one neighbor.

NOTE:

It is guaranteed that the array contains only a single peak element.
Users are expected to solve this in O(log(N)) time. The array may contain duplicate elements.


Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 109

Example Input

Input 1:

A = [1, 2, 3, 4, 5]
Input 2:

A = [5, 17, 100, 11]




Example Output

Output 1:


 5
Output 2:

 100


Example Explanation

Explanation 1:

 5 is the peak.
Explanation 2:

 100 is the peak.


 Approach - 


 Problem Setup (restating)

We are guaranteed exactly one peak exists.

A peak = element â‰¥ neighbors.

Corners only need one neighbor check.

Duplicates allowed, but not "too many" (explained later).

You must find the index of the peak in O(log N).

ðŸ”¹ Hints Breakdown
1. â€œArray can be one of 3 typesâ€

This is the structural guarantee. If only one peak exists, the array cannot be random; it must look like one of these:

Strictly Decreasing
[9, 7, 5, 3] â†’ Peak is at index 0.

Strictly Increasing
[1, 4, 6, 9] â†’ Peak is at index n-1.

Increasing then Decreasing (mountain shape)
[1, 3, 8, 12, 4, 2] â†’ Peak is at 12 (the top of the mountain).

This restriction is why binary search works:

If you look at the middle element, you can decide which side to go.

The "mountain" guarantees you donâ€™t skip the unique peak.

2. â€œAt most one pair of equal adjacent elementsâ€

Why this rule? Because duplicates can create multiple peaks if unrestricted.

Example (invalid case):
[5, 5, 5] â†’ all three are peaks, violates uniqueness.

So rules:

No 3 consecutive equal elements.

At most one pair equal: [1, 3, 5, 5, 2] â†’ Peak is one of the 5s.

This ensures uniqueness of peak is still valid even with duplicates.

3. â€œIf duplicates exist, one must be the peakâ€

If A[i] == A[i+1], then one of them must satisfy the "not smaller than both neighbors" condition.

Example:
[1, 3, 5, 5, 2]

Both 5s are â‰¥ neighbors, so either index is valid as the peak.

This rule simplifies the problem so binary search doesnâ€™t break on equals.

4. â€œCan you apply binary search for the index?â€

Yes. Hereâ€™s the trick binary search uses:

At index mid:

If A[mid] > A[mid+1], it means we are in the decreasing slope of the mountain â†’ the peak is at mid or to the left, so move r = mid.

Else (A[mid] <= A[mid+1]), we are in the increasing slope â†’ the peak is to the right, so move l = mid + 1.

This works because the array is shaped like a mountain (one peak) and binary search â€œwalksâ€ towards it.

Code - 

  public int solve(int[] A) {

        int l=0, r=A.length-1;

        while( l < r){

            int mid = (l+r)/2;

            if( mid+1 < A.length && A[mid] > A[mid+1]  ){
                 r=mid;
            }else{
                l=mid+1;
            }
        }

        return A[l];
       
    }

    