Q - Add Binary Strings

Problem Description

Given two binary strings A and B. Return their sum (also a binary string).


Problem Constraints

1 <= length of A <= 105

1 <= length of B <= 105

A and B are binary strings



Input Format

The two argument A and B are binary strings.



Output Format

Return a binary string denoting the sum of A and B



Example Input

Input 1:
A = "100"
B = "11"
Input 2:
A = "110"
B = "10"


Example Output

Output 1:
"111"
Output 2:
"1000"


Example Explanation

For Input 1:
The sum of 100 and 11 is 111.
For Input 2:
 
The sum of 110 and 10 is 1000.

Code - 

 public String addBinary(String A, String B) {

        StringBuilder ans = new StringBuilder();
        int i = A.length()-1;
        int j = B.length()-1;

        int carry =0;

        while( i>= 0 || j >= 0 || carry >0){
            int bitA = (i>=0) ? A.charAt(i--)-'0' :0;
            int bitB = (j>=0) ? B.charAt(j--)-'0':0;

            int sum = bitA + bitB+carry;
            ans.append(sum%2);
            carry = sum/2;
        }

        return ans.reverse().toString();
    }


Q -  Set Bit

Problem Description

You are given two integers A and B.
Set the A-th bit and B-th bit in 0, and return output in decimal Number System.

Note:
The bit positions are 0-indexed, which means that the least significant bit (LSB) has index 0.


Problem Constraints

0 <= A <= 30
0 <= B <= 30


Input Format

First argument A is an integer.
Second argument B is an integer.


Output Format

Return an integer.


Example Input

Input 1:
A = 3
B = 5
Input 2:
A = 4
B = 4


Example Output

Output 1:
40
Output 2:
16


Example Explanation

For Input 1:
The binary expression is 101000 which is 40 in decimal.
For Input 2:
The binary expression is 10000 which is 16 in decimal


Approach - 

The value of the A-th bit is 2^A and that
of the B-th bit is 2^B.
We have to set the A-th bit and the B-th bit
in 0. This is similar to directly adding 2^A 
and 2^B to 0. 
If A = B, then we can just add 2^A to 0.

Time Complexity : O(1)
Space Complexity : O(1)

Code - 

  public int solve(int A, int B) {

        int ans =0;

        if( A == B){
        ans = ans | (1 << A);  
        return ans;  
        }else{
            ans = ans | (1 << A);
        ans = ans | (1 << B);
        return ans;
        }
    }

Q -  Unset i-th bit

Problem Description

You are given two integers A and B.
If B-th bit in A is set, make it unset.
If B-th bit in A is unset, leave as it is.
Return the updated A value.

Note:
The bit position is 0-indexed, which means that the least significant bit (LSB) has index 0.


Problem Constraints

1 <= A <= 109
0 <= B <= 30


Input Format

First argument A is an integer.
Second argument B is an integer.


Output Format

Return an integer.


Example Input

Input 1:
A = 4
B = 1
Input 2:
A = 5
B = 2


Example Output

Output 1:
4
Output 2:
1


Example Explanation

For Input 1:
Given N = 4 which is 100 in binary. The 1-st bit is already unset
For Input 2:
Given N = 5 which is 101 in binary. We unset the 2-nd bit
It becomes 001 which is 1 in Decimal.

Code - 

    public int solve(int A, int B) {

        int setBit = 1 << B;
        setBit = ~setBit;
        return A & setBit;
    }


Q - Check bit


You are given two integers A and B.
Return 1 if B-th bit in A is set
Return 0 if B-th bit in A is unset
Note:
The bit position is 0-indexed, which means that the least significant bit (LSB) has index 0.


Code - 

    public int solve(int A, int B) {

        int bit = 1 << B;

        if( (A & bit) > 0){
            return 1;
        }

        return 0;
    }

Q - Number of 1 Bits

Problem Description

Write a function that takes an integer and returns the number of 1 bits present in its binary representation.


Problem Constraints

1 <= A <= 109


Input Format

First and only argument contains integer A


Output Format

Return an integer


Example Input

Input 1:
11
Input 2:
6


Example Output

Output 1:
3
Output 2:
2


Example Explanation

Explaination 1:
11 is represented as 1011 in binary.
Explaination 2:
6 is represented as 110 in binary.

Code - 

    public int numSetBits(int A) {

        int ans =0;

        for( int i=0; i< 32; i++){

            if( (A & (1 << i)) > 0){
                ans++;
            }
        }

        return ans;
    }

Q - Help From Sam


Problem Description

Alex and Sam are good friends. Alex is doing a lot of programming these days. He has set a target score of A for himself.
Initially, Alex's score was zero. Alex can double his score by doing a question, or Alex can seek help from Sam for doing questions that will contribute 1 to Alex's score. Alex wants his score to be precisely A. Also, he does not want to take much help from Sam.

Find and return the minimum number of times Alex needs to take help from Sam to achieve a score of A.


Problem Constraints

0 <= A <= 10^9


Input Format

The only argument given is an integer A.


Output Format

Return the minimum number of times help taken from Sam.


Example Input

Input 1:
A = 5
Input 2:

A = 3


Example Output

Output 1:
2
Output 2:

2


Example Explanation

Explanation 1:
Initial score : 0
Takes help from Sam, score : 1
Alex solves a question, score : 2
Alex solves a question, score : 4
Takes help from Sam, score: 5
Explanation 2:

Initial score : 0
Takes help from Sam, score : 1
Alex solves a question, score : 2
Takes help from Sam, score : 3

Approach - 

Claim :The number of times we would require help from sam is the number of bits that are set in A.

Lets try to build an intuition for this. Instead of going from 0 to A , we will go in the reverse direction i.e. from A to 0.
First initialise a cnt variable to 0 which is the number of times we took help from sam.Now we would follow this approach until A becomes 0.

If A is an even number we can divide it by 2
otherwise if A is an odd number we can subtract 1 from it and increment the cnt.

Since every time we divide by 2 if its an even number , it is same as doing a left shift. The number of times A would become odd is the number of set bits of A.

Lets take an example to make this more clear:

A=17
0) 17 ,cnt=0
1) 17 -> 16 , cnt=1
2) 16 -> 8 , cnt=1
3) 8 -> 4 , cnt=1
4) 4 -> 2 , cnt=1
5) 2 -> 1 , cnt=1
6) 1 -> 0 , cnt=2

binary representation of 17 = 10001 , and we can see that the number of set bits is the same as cnt that we obtained in the above approach.

Therefore it is enough to just find the number of set bits of A.

We can do this as follows:

cnt=0
for i from 0 to 31
    if A&(1<<i) != 0 
        cnt++
return cnt
Time Complexity : O( log(A) )

Code - 

 public int solve(int A) {

        int count =0;

        while( A > 0){
            if( ( A & 1) > 0){
                count++;
            }

            A = A >> 1;
        }

        return count;
    }

Q - Toggle i-th bit


Problem Description

You are given two integers A and B.
If B-th bit in A is set, make it unset
If B-th bit in A is unset, make it set
Return the updated A value


Problem Constraints

1 <= A <= 109
0 <= B <= 30


Input Format

First argument A is an integer.
Second argument B is an integer.


Output Format

Return an integer.


Example Input

Input 1:
A = 4
B = 1
Input 2:
A = 5
B = 2


Example Output

Output 1:
6
Output 2:
1


Example Explanation

For Input 1:
Given N = 4 which is 100 in binary. The 1-st bit is unset
so we make it set
For Input 2:
 
Given N = 5 which is 101 in binary. The 2-nd bit is set
so we make it unset

Code - 

    public int solve(int A, int B) {

        int setBit = 1 << B;

        return (A ^ setBit);
    }

Q - Unset x bits from right

Problem Description

Given an integer A. Unset B bits from the right of A in binary.

For example, if A = 93 and B = 4, the binary representation of A is 1011101.
If we unset the rightmost 4 bits, we get the binary number 1010000, which is equal to the decimal value 80.


Problem Constraints

1 <= A <= 1018
1 <= B <= 60


Input Format

The first argument is a single integer A.
The second argument is a single integer B.


Output Format

Return the number with B unset bits from the right.


Example Input

Input 1:-
A = 25
B = 3
Input 2:-
A = 37
B = 3


Example Output

Output 1:-
24
Output 2:-
32


Example Explanation

Explanation 1:-
A = 11001 to 11000
Explantio 2:-
A = 100101 to 100000

Code - 

    public long solve(long A, int B) {

        int bit =1;
        B--;
        while(B >= 0){
            bit = ~(1 << B);
            A = A & bit;
            B--;
        }

        return A;
    }