Q - Single Number II


Problem Description

Given an array of integers, every element appears thrice except for one, which occurs once.

Find that element that does not appear thrice.

NOTE: Your algorithm should have a linear runtime complexity.

Could you implement it without using extra memory?




Problem Constraints

2 <= |A| <= 5*106

0 <= A[i] <= INTMAX



Input Format

First and only argument of input contains an integer array A.



Output Format

Return a single integer.



Example Input

Input 1:

 A = [1, 2, 4, 3, 3, 2, 2, 3, 1, 1]
Input 2:

 A = [0, 0, 0, 1]


Example Output

Output 1:

 4
Output 2:

 1


Example Explanation

Explanation 1:

 4 occurs exactly once in Input 1.
 1 occurs exactly once in Input 2.

 Approach - 

 Find count of set-bits for all bit positions one by one for all numbers.
If, for ith bit -
count of set-bits % 3 is equal to 0, that means ith bit in the number is unset.
count of set bits % 3 is equal to 1, that means ith bit in the number is set.

code - 

  public int singleNumber(final int[] A) {

        int ans=0;
        int cnt=0;

        for( int j=0; j<32; j++){
        
        cnt=0;
        for( int i=0; i<A.length; i++){

            if( (A[i] & (1 << j)) > 0 ){
                cnt++;
            }
        }

        if( cnt%3 != 0){
            ans = ans | (1 << j);
        }

    }

    return ans;
    }


Q - Single Number III

Problem Description

Given an array of positive integers A, two integers appear only once, and all the other integers appear twice.
Find the two integers that appear only once.

Note: Return the two numbers in ascending order.


Problem Constraints

2 <= |A| <= 100000
1 <= A[i] <= 109



Input Format

The first argument is an array of integers of size N.



Output Format

Return an array of two integers that appear only once.



Example Input

Input 1:
A = [1, 2, 3, 1, 2, 4]
Input 2:

A = [1, 2]


Example Output

Output 1:
[3, 4]
Output 2:

[1, 2]


Example Explanation

Explanation 1:
3 and 4 appear only once.
Explanation 2:

1 and 2 appear only once.


Approach - 

If we use additional memory, we can directly store the count and find the integers which occur only once.
To solve without additional memory, We can use the xor operation, as the Xor of two integers gives 0.
Take the Xor of all the integers of the array. Integers that occur twice will not contribute anything to the xor value.
Suppose that the ith bit is set in the xor value, which means that exactly one of the two required numbers has that bit set.
If we then divide the array integers into two groups: one group contains all integers with the ith bit set, and the other group contains integers with 0 at the ith bit.
Each group includes one of the two required numbers, and for the rest of the numbers, both of their occurrences will be in the same group.
Now, Xor of integers in the first group gives a number that occurs exactly once. Xor of integers in the second group provides another number that appears exactly once.

Code  - 

 public int[] solve(int[] A) {

        int xor=0;

        for( int i =0; i< A.length; i++){
            xor = xor ^ A[i];
        }

        int firstSetBit = 0;
        int j=0;

        while((xor & (1 << j++) ) == 0){
            firstSetBit++;
        }

        int xorSet1 =0;
        int xorSet2 =0;

        for( int i=0; i< A.length; i++){

            if( (A[i] & (1 << firstSetBit)) > 0 ){
                xorSet1 = xorSet1 ^ A[i];
            }else{
                xorSet2 = xorSet2 ^ A[i];
            }
        }

        int[] ans = new int[2];

        if( xorSet1 > xorSet2){

        ans[0] = xorSet2;
        ans[1] = xorSet1;
        }
        else{
        ans[0] = xorSet1;
        ans[1] = xorSet2;
        }

        return ans;

    }

Q - Find Two Missing Numbers

Problem Description

Given an array A of length N where all the elements are distinct and are in the range [1, N+2].

Two numbers from the range [1, N+2] are missing from the array A. Find the two missing numbers.



Problem Constraints

1 <= N <= 105

1 <= A[i] <= N+2

The elements of array A are distinct



Input Format

Only argument A is an array of integers



Output Format

Return a sorted array of size 2 denoting the missing elements.



Example Input

Input 1:
A = [3, 2, 4]
Input 2:
A = [5, 1, 3, 6]


Example Output

Output 1:
[1, 5]
Output 2:
[2, 4]


Example Explanation

For Input 1:
The missing numbers are 1 and 5.
For Input 2:
The missing numbers are 2 and 4.

Approach -

We will calculate the xor of all the elements of the array and
xor this value will all integers from 1 to N+2.
Finally, we will have the xor of the two missing numbers.

Let the missing numbers be X and Y
A bit is set in xor only if corresponding bits in X and Y are different.

So, we find one of the set bits of X^Y and then divide all the element with
that bit set in one group and those with that bit unset in another group.

Here, both X and Y will belong to different group. We can easily find the 
missing number in each group.


Time Complexity : O(N)
Space Complexity : O(1)


Code - 

public int[] solve(int[] A) {

        int xorAll =0;

        for( int i=1; i<= A.length+2; i++){
            xorAll = xorAll ^ i;
        }

        int xorArr =0;

        for( int j =0; j< A.length;j++){
            xorArr = xorArr ^ A[j];
        }

        int xor = xorAll ^ xorArr;


        int firstBit =0;

        int k=0;

        while( ( xor & ( 1 << k)) == 0){
            firstBit++;
            k++;
        }

        // firstBit++;

        
        int xorGroup1 = 0;
        int xorGroup2 = 0;

        
        for( int i=1; i<= A.length+2; i++){
            
            if( ( i & ( 1 << firstBit) ) > 0){
                xorGroup1 = xorGroup1 ^ i;
            }else{
                xorGroup2 = xorGroup2 ^ i;
            }
        }

          for( int i=0; i< A.length; i++){
            
            if( ( A[i] & ( 1 << firstBit) ) > 0){
                xorGroup1 = xorGroup1 ^ A[i];
            }else{
                xorGroup2 = xorGroup2 ^ A[i];
            }
        }

        int[] ans = new int[2];

        if(xorGroup1 > xorGroup2){
            ans[0] = xorGroup2;
            ans[1] = xorGroup1;
        }else{
            ans[0] = xorGroup1;
            ans[1] = xorGroup2;
        }

        return ans;

    }

Q - Maximum AND Pair


Problem Description

Given an array A. For every pair of indices i and j (i != j), find the maximum A[i] & A[j].


Problem Constraints

1 <= len(A) <= 105
1 <= A[i] <= 109


Input Format

The first argument is an integer array A.


Output Format

Return a single integer that is the maximum A[i] & A[j].


Example Input

Input 1:-
A = [53, 39, 88]
Input 2:-
A = [38, 44, 84, 12] 


Example Output

Output 1:-
37
Output 2:-
36


Example Explanation

Explanation 1:-
53 & 39 = 37
39 & 88 = 0
53 & 88 = 16
Maximum among all these pairs is 37
Explanation 2:-
Maximum bitwise and among all pairs is (38, 44) = 36


Approach -

2^i is larger than sum of all 2^j for j in range(0,i-1). 
So try to greedily include the largest bits in the final answer and minimize the array.

Iterate from the largest possible bit to smallest bit 0. Create another empty set of numbers say st.
Iterate over the current set of numbers, if the number has the current bit set then include this number in st.
If size of st is greater than 1 that is atleast one pair is possible then replace current set with st. 
Else continue to next bit.
Finally after and of any two elements in the current set will have the largest ands as we have removed the lower and pairs.

Time Complexity - O(32 * N). Since there can be upto 32 bits, we iterate and 
create new sets 32 times reducing the set everytime.
Space Complexity - O(N)


Code - 

 public int solve(int[] A) {

        int ans=0;
        int n = A.length;
        int cnt=0;
        for( int i =31; i >= 0; i--){
             cnt = 0;

            for( int j =0; j < n; j++){

                if( checkBit(A[j], i)){
                   cnt++;  
                }
            }

            if( cnt >= 2){
                ans = ans | (1 << i);

                for( int k=0; k< n; k++){

                    if( !checkBit(A[k] , i)){
                        A[k] = 0;
                    }
                }
            }
        }

        return ans;
    }

    public boolean checkBit(int val, int k){

        if(( val & ( 1 << k)) > 0){
            return true;

        }else{
            return false;
        }
    }

Q -  SUBARRAY OR


Problem Description

You are given an array of integers A of size N.

The value of a subarray is defined as BITWISE OR of all elements in it.

Return the sum of value of all subarrays of A % 109 + 7.



Problem Constraints

1 <= N <= 105

1 <= A[i] <= 108



Input Format

The first argument given is the integer array A.



Output Format

Return the sum of Value of all subarrays of A % 109 + 7.



Example Input

Input 1:

 A = [1, 2, 3, 4, 5]
Input 2:

 A = [7, 8, 9, 10]


Example Output

Output 1:

 71
Output 2:

 110


Example Explanation

Explanation 1:

 Value([1]) = 1
 Value([1, 2]) = 3
 Value([1, 2, 3]) = 3
 Value([1, 2, 3, 4]) = 7
 Value([1, 2, 3, 4, 5]) = 7
 Value([2]) = 2
 Value([2, 3]) = 3
 Value([2, 3, 4]) = 7
 Value([2, 3, 4, 5]) = 7
 Value([3]) = 3
 Value([3, 4]) = 7
 Value([3, 4, 5]) = 7
 Value([4]) = 4
 Value([4, 5]) = 5
 Value([5]) = 5
 Sum of all these values = 71
Explanation 2:

 Sum of value of all subarray is 110.


 Approach - 

 
Approach - 

In this question, we will consider every bit as a unique bit, and every bit will have an independent contribution to the answer.
Thus, we will iterate over the whole array for all bits independently. We will maintain a 2d array BitInfo[bits][index]. The value at any index ind for any bit will signify the next index on which this bit is set.
Thus after that index, every subarray corresponding to ind will have that bit set. 
In this manner, the contribution of every bit corresponding to each bit can be determined independently and can be added to the overall answer.

Another way to solve this problem is to iterate over each bit and count the number of subarrays in which it won't contribute.
After calculating that, we can deduct this from the total count of subarrays(which is the same for each bit).
To count the number of subarrays in which a bit won't have a contribution, consider the following example for a random bit:
0 1 1 0 0 0 0 1 1 0 0 1 (0 is for the places where the bit is unset, and 1 is for the places where this bit is set)
If the starting till ending point of a subarray does not consist of even a single 1, the bit won't contribute to the bitwise OR.
The number of subarrays that can be formed from an array of size x is x * (x + 1) / 2. So, we can iterate over this binary array
that we had precomputed for each bit before and applied the formula to get the total number of subarrays where the selected bit does not contribute to bitwise OR.


Code - 
 public int solve(int[] A) {
        int n = A.length;
        long result = 0;
        int MOD = 1_000_000_007;

        Map<Integer, Integer> prev = new HashMap<>();
        Map<Integer, Integer> curr = new HashMap<>();

        for (int i = 0; i < n; i++) {
            curr.clear();

            // Start a new subarray from A[i]
            curr.put(A[i], 1);

            // Extend all subarrays from previous step
            for (Map.Entry<Integer, Integer> entry : prev.entrySet()) {
                int newOr = entry.getKey() | A[i];
                curr.put(newOr, curr.getOrDefault(newOr, 0) + entry.getValue());
            }

            // Sum contributions from this step
            for (Map.Entry<Integer, Integer> entry : curr.entrySet()) {
                result = (result + (1L * entry.getKey() * entry.getValue()) % MOD) % MOD;
            }

            // Update for next iteration
            prev = new HashMap<>(curr);
        }

        return (int) result;
    }


Q -  Strange Equality

Problem Description

Given an integer A.
Two numbers, X and Y, are defined as follows:

X is the greatest number smaller than A such that the XOR sum of X and A is the same as the sum of X and A.
Y is the smallest number greater than A, such that the XOR sum of Y and A is the same as the sum of Y and A.
Find and return the XOR of X and Y.

NOTE 1: XOR of X and Y is defined as X ^ Y where '^' is the BITWISE XOR operator.

NOTE 2: Your code will be run against a maximum of 100000 Test Cases.



Problem Constraints

1 <= A <= 109



Input Format

First and only argument is an integer A.



Output Format

Return an integer denoting the XOR of X and Y.



Example Input

A = 5


Example Output

10


Example Explanation

The value of X will be 2 and the value of Y will be 8. The XOR of 2 and 8 is 10.

Approach - 

A + B = (A ^ B) + 2 * (A & B)
Following the above equation, if xor sum and the sum of 2 numbers are equal, their bitwise AND should be zero.
Given a number N, how to find a number whose bitwise AND with N is 0?
Keeping in mind the truth table of AND, 1 & 1 = 1 while 1 & 0 = 0, 0 & 1 = 0 and 0 & 0 = 0.
Therefore, in the number X such that X & N is 0, all the set bits of number N must be unset in the number X since 1 & 0 = 0.
The unset bits of N can have any orientation in X, that is, they can either be 0 or be 1.
So to find the smallest number greater than N, the answer is the next power of 2 greater than N. Think why!!
And to find the greatest number smaller than N, set all the unset bits of N to 1.

Code - 

 public int solve(int A) {

        int x = 0;
        int mostSignificantSetBit = 0;

        // Find the most significant set bit
        for (int i = 30; i >= 0; i--) {
            if ((A & (1 << i)) != 0) {
                mostSignificantSetBit = i;
                break;
            }
        }

        // Set bits in x where A has 0s (up to the MSB)
        for (int i = 0; i <= mostSignificantSetBit; i++) {
            if ((A & (1 << i)) == 0) {
                x |= (1 << i);
            }
        }

        int y = 1 << (mostSignificantSetBit + 1);

        return x ^ y;

    }
    

Q -  Sum of Xor of all Pairs

Problem Description

Given an array A of N integers. Find the sum of bitwise XOR all pairs of numbers in the array.

Since the answer can be large, return the remainder after the dividing the answer by 109+7.



Problem Constraints

1 <= N <= 105

1 <= A[i] < 109



Input Format

Only argument A is an array of integers



Output Format

Return an integer denoting the sum of xor of all pairs of number in the array.



Example Input

Input 1:
A = [1, 2, 3]
Input 2:
A = [3, 4, 2]


Example Output

Output 1:
6
Output 2:
14


Example Explanation

For Input 1:
Pair    Xor
{1, 2}  3
{1, 3}  2
{2, 3}  1
Sum of xor of all pairs = 3 + 2 + 1 = 6.
For Input 2:
Pair    Xor
{3, 4}  7
{3, 2}  1
{4, 2}  6
Sum of xor of all pairs = 7 + 1 + 6 = 14.


Approach - 

For every bit, we can find the number of elements in the array 
with that bit set and the number of elements with that bit unset.

Let the number of elements with i-th bit set and unset be 
X and Y respectively.

Now the number of xor pairs with the i-th bit set is X*Y. 
So the total contribution by the i-th bit to the sum of xor
of all pairs will be (X * Y) * (1 << i).


Time Complexity : O(N*logX)
Space Complexity : O(1)

where X is maximum value from A

Code - 

  public int solve(int[] A) {

            int ans=0;
            long setCnt=0, unSetCnt=0;
            int mod = 1000000007;
            long multiplier=0;

            for( int i =0 ; i < 32; i++){
                
                setCnt=0;
                unSetCnt=0;

                for(int j=0; j < A.length; j++){
                if( (A[j] & (1 << i)) > 0 ){
                    setCnt++;
                }else{
                    unSetCnt++;
                }
                }
                
                
                multiplier = ((1L << i) % mod);
                long temp = (setCnt * unSetCnt) % mod;
                temp = (temp * multiplier) % mod;
                ans = (int)((ans + temp) % mod);
                

                // ans = (ans % mod + ( (int) ((setCnt * unSetCnt)% mod ) * (int) multiplier ) % mod ) % mod;
            }

            return ans;
    }


       public int solveBF(int[] A) {

        int ans =0;
        long tempXor=0;

        int mod = 1000000007;
        for( int i =0; i< A.length; i++){

            for( int j = i ; j < A.length; j++){

                if( i == j)
                continue;

                tempXor = ( (A[i] % mod) ^ (A[j] % mod) ) % mod;
                ans = (ans + (int) tempXor) % mod  ;
            }
        }

        return ans;
    }

    