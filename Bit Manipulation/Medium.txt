Q - Single Number II


Problem Description

Given an array of integers, every element appears thrice except for one, which occurs once.

Find that element that does not appear thrice.

NOTE: Your algorithm should have a linear runtime complexity.

Could you implement it without using extra memory?




Problem Constraints

2 <= |A| <= 5*106

0 <= A[i] <= INTMAX



Input Format

First and only argument of input contains an integer array A.



Output Format

Return a single integer.



Example Input

Input 1:

 A = [1, 2, 4, 3, 3, 2, 2, 3, 1, 1]
Input 2:

 A = [0, 0, 0, 1]


Example Output

Output 1:

 4
Output 2:

 1


Example Explanation

Explanation 1:

 4 occurs exactly once in Input 1.
 1 occurs exactly once in Input 2.

 Approach - 

 Find count of set-bits for all bit positions one by one for all numbers.
If, for ith bit -
count of set-bits % 3 is equal to 0, that means ith bit in the number is unset.
count of set bits % 3 is equal to 1, that means ith bit in the number is set.

code - 

  public int singleNumber(final int[] A) {

        int ans=0;
        int cnt=0;

        for( int j=0; j<32; j++){
        
        cnt=0;
        for( int i=0; i<A.length; i++){

            if( (A[i] & (1 << j)) > 0 ){
                cnt++;
            }
        }

        if( cnt%3 != 0){
            ans = ans | (1 << j);
        }

    }

    return ans;
    }


Q - Single Number III

Problem Description

Given an array of positive integers A, two integers appear only once, and all the other integers appear twice.
Find the two integers that appear only once.

Note: Return the two numbers in ascending order.


Problem Constraints

2 <= |A| <= 100000
1 <= A[i] <= 109



Input Format

The first argument is an array of integers of size N.



Output Format

Return an array of two integers that appear only once.



Example Input

Input 1:
A = [1, 2, 3, 1, 2, 4]
Input 2:

A = [1, 2]


Example Output

Output 1:
[3, 4]
Output 2:

[1, 2]


Example Explanation

Explanation 1:
3 and 4 appear only once.
Explanation 2:

1 and 2 appear only once.


Approach - 

If we use additional memory, we can directly store the count and find the integers which occur only once.
To solve without additional memory, We can use the xor operation, as the Xor of two integers gives 0.
Take the Xor of all the integers of the array. Integers that occur twice will not contribute anything to the xor value.
Suppose that the ith bit is set in the xor value, which means that exactly one of the two required numbers has that bit set.
If we then divide the array integers into two groups: one group contains all integers with the ith bit set, and the other group contains integers with 0 at the ith bit.
Each group includes one of the two required numbers, and for the rest of the numbers, both of their occurrences will be in the same group.
Now, Xor of integers in the first group gives a number that occurs exactly once. Xor of integers in the second group provides another number that appears exactly once.

Code  - 

 public int[] solve(int[] A) {

        int xor=0;

        for( int i =0; i< A.length; i++){
            xor = xor ^ A[i];
        }

        int firstSetBit = 0;
        int j=0;

        while((xor & (1 << j++) ) == 0){
            firstSetBit++;
        }

        int xorSet1 =0;
        int xorSet2 =0;

        for( int i=0; i< A.length; i++){

            if( (A[i] & (1 << firstSetBit)) > 0 ){
                xorSet1 = xorSet1 ^ A[i];
            }else{
                xorSet2 = xorSet2 ^ A[i];
            }
        }

        int[] ans = new int[2];

        if( xorSet1 > xorSet2){

        ans[0] = xorSet2;
        ans[1] = xorSet1;
        }
        else{
        ans[0] = xorSet1;
        ans[1] = xorSet2;
        }

        return ans;

    }

Q - Find Two Missing Numbers

Problem Description

Given an array A of length N where all the elements are distinct and are in the range [1, N+2].

Two numbers from the range [1, N+2] are missing from the array A. Find the two missing numbers.



Problem Constraints

1 <= N <= 105

1 <= A[i] <= N+2

The elements of array A are distinct



Input Format

Only argument A is an array of integers



Output Format

Return a sorted array of size 2 denoting the missing elements.



Example Input

Input 1:
A = [3, 2, 4]
Input 2:
A = [5, 1, 3, 6]


Example Output

Output 1:
[1, 5]
Output 2:
[2, 4]


Example Explanation

For Input 1:
The missing numbers are 1 and 5.
For Input 2:
The missing numbers are 2 and 4.

Approach -

We will calculate the xor of all the elements of the array and
xor this value will all integers from 1 to N+2.
Finally, we will have the xor of the two missing numbers.

Let the missing numbers be X and Y
A bit is set in xor only if corresponding bits in X and Y are different.

So, we find one of the set bits of X^Y and then divide all the element with
that bit set in one group and those with that bit unset in another group.

Here, both X and Y will belong to different group. We can easily find the 
missing number in each group.


Time Complexity : O(N)
Space Complexity : O(1)


Code - 

public int[] solve(int[] A) {

        int xorAll =0;

        for( int i=1; i<= A.length+2; i++){
            xorAll = xorAll ^ i;
        }

        int xorArr =0;

        for( int j =0; j< A.length;j++){
            xorArr = xorArr ^ A[j];
        }

        int xor = xorAll ^ xorArr;


        int firstBit =0;

        int k=0;

        while( ( xor & ( 1 << k)) == 0){
            firstBit++;
            k++;
        }

        // firstBit++;

        
        int xorGroup1 = 0;
        int xorGroup2 = 0;

        
        for( int i=1; i<= A.length+2; i++){
            
            if( ( i & ( 1 << firstBit) ) > 0){
                xorGroup1 = xorGroup1 ^ i;
            }else{
                xorGroup2 = xorGroup2 ^ i;
            }
        }

          for( int i=0; i< A.length; i++){
            
            if( ( A[i] & ( 1 << firstBit) ) > 0){
                xorGroup1 = xorGroup1 ^ A[i];
            }else{
                xorGroup2 = xorGroup2 ^ A[i];
            }
        }

        int[] ans = new int[2];

        if(xorGroup1 > xorGroup2){
            ans[0] = xorGroup2;
            ans[1] = xorGroup1;
        }else{
            ans[0] = xorGroup1;
            ans[1] = xorGroup2;
        }

        return ans;

    }

Q - Maximum AND Pair


Problem Description

Given an array A. For every pair of indices i and j (i != j), find the maximum A[i] & A[j].


Problem Constraints

1 <= len(A) <= 105
1 <= A[i] <= 109


Input Format

The first argument is an integer array A.


Output Format

Return a single integer that is the maximum A[i] & A[j].


Example Input

Input 1:-
A = [53, 39, 88]
Input 2:-
A = [38, 44, 84, 12] 


Example Output

Output 1:-
37
Output 2:-
36


Example Explanation

Explanation 1:-
53 & 39 = 37
39 & 88 = 0
53 & 88 = 16
Maximum among all these pairs is 37
Explanation 2:-
Maximum bitwise and among all pairs is (38, 44) = 36


Approach -

2^i is larger than sum of all 2^j for j in range(0,i-1). 
So try to greedily include the largest bits in the final answer and minimize the array.

Iterate from the largest possible bit to smallest bit 0. Create another empty set of numbers say st.
Iterate over the current set of numbers, if the number has the current bit set then include this number in st.
If size of st is greater than 1 that is atleast one pair is possible then replace current set with st. 
Else continue to next bit.
Finally after and of any two elements in the current set will have the largest ands as we have removed the lower and pairs.

Time Complexity - O(32 * N). Since there can be upto 32 bits, we iterate and 
create new sets 32 times reducing the set everytime.
Space Complexity - O(N)


Code - 

 public int solve(int[] A) {

        int ans=0;
        int n = A.length;
        int cnt=0;
        for( int i =31; i >= 0; i--){
             cnt = 0;

            for( int j =0; j < n; j++){

                if( checkBit(A[j], i)){
                   cnt++;  
                }
            }

            if( cnt >= 2){
                ans = ans | (1 << i);

                for( int k=0; k< n; k++){

                    if( !checkBit(A[k] , i)){
                        A[k] = 0;
                    }
                }
            }
        }

        return ans;
    }

    public boolean checkBit(int val, int k){

        if(( val & ( 1 << k)) > 0){
            return true;

        }else{
            return false;
        }
    }

Q -  SUBARRAY OR


Problem Description

You are given an array of integers A of size N.

The value of a subarray is defined as BITWISE OR of all elements in it.

Return the sum of value of all subarrays of A % 109 + 7.



Problem Constraints

1 <= N <= 105

1 <= A[i] <= 108



Input Format

The first argument given is the integer array A.



Output Format

Return the sum of Value of all subarrays of A % 109 + 7.



Example Input

Input 1:

 A = [1, 2, 3, 4, 5]
Input 2:

 A = [7, 8, 9, 10]


Example Output

Output 1:

 71
Output 2:

 110


Example Explanation

Explanation 1:

 Value([1]) = 1
 Value([1, 2]) = 3
 Value([1, 2, 3]) = 3
 Value([1, 2, 3, 4]) = 7
 Value([1, 2, 3, 4, 5]) = 7
 Value([2]) = 2
 Value([2, 3]) = 3
 Value([2, 3, 4]) = 7
 Value([2, 3, 4, 5]) = 7
 Value([3]) = 3
 Value([3, 4]) = 7
 Value([3, 4, 5]) = 7
 Value([4]) = 4
 Value([4, 5]) = 5
 Value([5]) = 5
 Sum of all these values = 71
Explanation 2:

 Sum of value of all subarray is 110.


 Approach - 

 